<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sedenioni v9.4</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* --- LAYOUT --- */
        #main-container { display: flex; width: 100vw; height: 100vh; overflow: hidden; position: relative; }
        
        #canvas-container {
            flex: 1; min-width: 0; position: relative;
            background-color: #1a1a1a;
            transition: background 0.5s ease;
        }

        /* --- SFONDI AMBIENTALI --- */
        .bg-default { background-color: #1a1a1a; }
        .bg-deep-space { background: radial-gradient(circle at center, #0b1026 0%, #000000 100%); }
        .bg-studio { background: radial-gradient(circle at center, #3a3a40 0%, #111 60%, #000 100%); }

        /* --- TOP BAR --- */
        #top-bar {
            position: absolute; top: 0; left: 0; right: 0;
            height: 60px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 15px;
            pointer-events: none; 
            z-index: 50;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        #top-bar > * { pointer-events: auto; }

        #main-title {
            color: white; font-size: 1.4em; font-weight: bold;
            text-shadow: 0 2px 4px black; margin: 0;
            text-align: center;
        }

        .bar-group { display: flex; gap: 10px; align-items: center; position: relative; }

        .ui-btn {
            width: 42px; height: 42px; 
            background: rgba(40, 40, 45, 0.8);
            border: 1px solid rgba(255,255,255,0.2); 
            border-radius: 8px;
            color: white; font-size: 20px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px); transition: 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .ui-btn:active { transform: scale(0.95); }
        .ui-btn.active { background: rgba(0, 136, 255, 0.8); border-color: #00aaff; color: white; }
        .icon-svg { width: 24px; height: 24px; fill: currentColor; }

        /* FIX UX: Impedisce la selezione del testo (effetto blu) su pulsanti e titoli */
        .ui-btn, #main-title, .tab-btn, .triplet-btn, .zerodiv-btn, .setting-action, .menu-btn, #sidebar-resizer {
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE10+/Edge */
            user-select: none;         /* Standard */
        }

        /* --- MENU IMPOSTAZIONI PRO --- */
        #settings-menu {
            position: absolute; top: 65px; left: 10px;
            background: rgba(28, 28, 32, 0.98);
            border: 1px solid #444; border-radius: 8px;
            padding: 12px; width: 240px;
            display: none; flex-direction: column; gap: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(12px); z-index: 200;
        }
        #settings-menu.visible { display: flex; animation: fadeInMenu 0.2s ease-out; }
        @keyframes fadeInMenu { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        .menu-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        .menu-btn {
            background: #333; border: 1px solid #444; color: #eee;
            padding: 10px; border-radius: 6px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 5px; transition: all 0.2s; height: 60px;
        }
        .menu-btn:hover { background: #444; border-color: #0088ff; color: white; }
        .menu-btn:active { transform: scale(0.96); }
        .menu-btn svg { width: 20px; height: 20px; fill: currentColor; }
        .menu-btn span { font-size: 11px; font-weight: 500; }

        .menu-btn.full-width { grid-column: span 2; flex-direction: row; height: 40px; gap: 10px; }

        .setting-row { display: flex; align-items: center; gap: 10px; color: #aaa; font-size: 11px; padding-top: 8px; border-top: 1px solid #333; margin-top: 5px; }
        
        /* Play/Pause Button Style */
        #play-pause-btn {
            width: 32px; height: 32px; flex-shrink: 0;
            background: #2a2a30; border: 1px solid #555; border-radius: 50%;
            color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            padding: 0; /* Rimuove padding default */
        }
        #play-pause-btn:hover { background: #444; border-color: #0088ff; color: #0088ff; transform: scale(1.05); }
        #play-pause-btn svg { width: 14px; height: 14px; fill: currentColor; }
        
        /* Slider Customization */
        input[type=range] { -webkit-appearance: none; background: transparent; flex: 1; min-width: 0; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #0088ff; cursor: pointer; margin-top: -5px; box-shadow: 0 0 5px rgba(0,136,255,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #444; border-radius: 2px;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 0; 
            background: #202025;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            transition: width 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            overflow: visible; 
            flex-shrink: 0;
            z-index: 100;
            position: relative;
        }
        #sidebar.open { width: 450px; }
        
        /* --- RESIZER MINIMAL --- */
        #sidebar-resizer {
            /* Posizionato a cavallo del bordo sinistro - AREA RIDOTTA per non coprire la tabella */
            position: absolute; 
            top: 40px; /* Spostato all'altezza corretta dei comandi */
            left: -20px; 
            height: 60px; /* Altezza limitata, non copre pi√π tutta la colonna */
            width: 40px;
            cursor: ew-resize; z-index: 150;
            background: transparent;
            display: flex; align-items: center; justify-content: center;
            touch-action: none; 
        }

        /* La linea verticale blu (sottile e discreta) */
        #sidebar-resizer::before {
            content: ''; position: absolute; top: 0; bottom: 0; left: 50%; width: 2px;
            background-color: #0088ff; transform: translateX(-50%);
            opacity: 0.5; transition: opacity 0.2s;
        }

        /* La maniglia centrale (pillola piccola senza frecce) */
        #sidebar-resizer::after {
            content: ''; 
            width: 6px; height: 24px; /* Molto pi√π piccolo e stretto */
            background: #0088ff; 
            border-radius: 10px; /* Forma a pillola */
            position: absolute; left: 50%; transform: translateX(-50%);
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
            transition: all 0.2s;
            z-index: 151;
        }

        /* Effetti Hover: diventa pi√π luminoso e leggermente pi√π alto */
        #sidebar-resizer:hover::before, #sidebar-resizer.active::before { opacity: 1; }
        #sidebar-resizer:hover::after, #sidebar-resizer.active::after {
            height: 32px; background: #33aaff; transform: translateX(-50%) scale(1.1);
        }
        /* ------------------------ */

        @media (max-width: 600px) {
            #sidebar.open { width: 100vw; position: absolute; height: 100%; right: 0; }
        }

        .sidebar-tabs {
            display: flex; background: #2a2a30; border-bottom: 1px solid #444;
            flex-shrink: 0; align-items: stretch;
        }
        .tab-btn {
            flex: 1; padding: 12px 5px; border: none; background: transparent;
            color: #888; cursor: pointer; font-weight: bold; border-bottom: 3px solid transparent;
            transition: all 0.2s; font-size: 11px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .tab-btn.active { color: white; border-bottom: 3px solid #0088ff; background: #333; }
        
        #close-sidebar-btn {
            width: 30px; background: #cc3333; border: none; color: white;
            font-size: 18px; cursor: pointer;
        }

        .tab-content { 
            flex: 1; 
            min-height: 0; 
            overflow: hidden; 
            display: none; 
            flex-direction: column; 
        }
        .tab-content.active { display: flex; }

        #triplets-scroll { flex: 1; overflow-y: auto; padding: 10px; }
        .triplets-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .triplet-btn {
            background: #333; color: #aaa; border: 1px solid #555;
            border-radius: 4px; padding: 10px 2px; font-size: 11px;
            cursor: pointer; text-align: center; font-family: monospace;
        }
        .triplet-btn.active { background: #004488; border-color: #4488ff; color: white; }

        #zerodiv-scroll { flex: 1; overflow-y: auto; padding: 10px; }
        #zerodiv-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 8px; 
        }
        .zerodiv-btn {
            background: #2a1515; color: #ffcccc; border: 1px solid #442222;
            border-radius: 4px; padding: 5px 2px; min-height: 45px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; text-align: center; font-family: 'Times New Roman', serif;
            font-size: 15px; line-height: 1.2;
        }
        .zerodiv-btn:hover { background: #552222; border-color: #ff4444; }
        .zerodiv-btn sub { font-size: 0.7em; vertical-align: baseline; position: relative; top: 0.3em; margin-left: 1px; }

        /* --- TABLE STYLES --- */
        #table-scroll { 
            flex: 0 0 auto; 
            overflow: auto; 
            height: 300px; /* Altezza iniziale di default */
            min-height: 50px;
            padding: 0; 
            background: #202025; 
            position: relative; 
            transition: none !important; /* Disabilita animazioni durante il resize */
        }
        #tab-table {
            overflow-y: auto;
            display: none;
            flex-direction: column;
        }
        #tab-table.active {
            display: flex;
        }
        #sedenion-table {
            border-collapse: separate; border-spacing: 0;
            font-family: 'Times New Roman', serif; font-size: 11px; table-layout: fixed;
        }
        #sedenion-table td, #sedenion-table th {
            border: 1px solid #ccc; text-align: center;
            white-space: nowrap; overflow: hidden; 
            height: 20px; min-width: 28px; width: 28px; padding: 2px 0;
            cursor: pointer; transition: box-shadow 0.1s;
        }
        #sedenion-table th { background-color: #333; color: white; position: sticky; top: 0; z-index: 100; }
        #sedenion-table .first-col {
            background-color: #333; color: white; position: sticky; left: 0; z-index: 101; font-weight: bold;
            border-right: 1px solid #555; width: 32px; min-width: 32px;
        }
        /* FIX: position relative fondamentale per l'highlight */
        .table-highlight { position: relative; } 
        .table-highlight::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.4); pointer-events: none;
        }
        .table-intersect {
            border: 2px solid black !important; font-weight: bold; transform: scale(1.1); z-index: 50;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .header-active { background-color: #0088ff !important; color: white !important; }
        #table-hint {
            padding: 8px; background: #202025; color: #888; font-size: 11px; 
            border-top: 1px solid #444; text-align: center; font-style: italic;
        }

        /* --- CALCULATOR --- */
        #calc-modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; max-width: 95vw; height: 670px; max-height: 95vh;
            background: #202025; border: 1px solid #555; border-radius: 8px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9); z-index: 2000;
            flex-direction: column; font-family: 'Segoe UI', sans-serif; overflow: hidden;
        }
        #calc-modal.active { display: flex; }

        .calc-header { 
            padding: 10px 15px; background: #2a2a30; border-bottom: 1px solid #444;
            display: flex; justify-content: space-between; align-items: center; color: white; 
            height: 50px; box-sizing: border-box; flex-shrink: 0;
        }
        .calc-mode-wrapper { display: flex; align-items: center; gap: 10px; flex: 1; }
        .calc-mode-sel { 
            background: #0066cc; color: white; border: 1px solid #0088ff; 
            padding: 5px 10px; font-size: 13px; font-weight: bold;
            border-radius: 4px; cursor: pointer; outline: none;
            transition: background 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .header-actions { display: flex; gap: 15px; align-items: center; }
        .icon-btn { cursor: pointer; font-size: 18px; color: #aaa; transition: 0.2s; user-select: none;}
        .icon-btn:hover { color: white; transform: scale(1.1); }
        .icon-btn.active { color: #00aaff; text-shadow: 0 0 5px #00aaff; }

        .calc-body { 
            flex: 1; padding: 12px; overflow: hidden; color: #ddd; 
            display: flex; flex-direction: column; position: relative;
        }
        .display-area {
            background: #111; border: 1px solid #444; border-radius: 6px;
            padding: 8px 10px; margin-bottom: 8px; display: flex; flex-direction: column; gap: 2px;
            flex-shrink: 0;
        }
        #expression-display {
            width: 100%; background: transparent; border: none; color: #888;
            font-family: monospace; font-size: 13px; outline: none; text-align: right;
        }
        #result-display {
            width: 100%; background: transparent; border: none; color: #0f0;
            font-family: monospace; font-size: 15px; font-weight: bold;
            text-align: right; min-height: 20px; white-space: normal; word-break: break-all; line-height: 1.2;
        }
        .var-tabs { display: flex; gap: 2px; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 0; flex-shrink: 0; }
        .var-tab {
            flex: 1; background: #2a2a2a; border: 1px solid #444; border-bottom: none; color: #888;
            padding: 6px 2px; text-align: center; cursor: pointer; border-radius: 4px 4px 0 0;
            font-size: 11px; font-weight: bold; transition: 0.2s;
        }
        .var-tab:hover { background: #333; }
        .var-tab.active { background: #333; color: white; border-top: 2px solid #0088ff; }
        .vector-inputs { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 8px; }
        .input-group { 
            display: flex; align-items: center; background: #151515; 
            border: 1px solid #333; padding: 1px 2px; border-radius: 3px; 
        }
        .input-group.hidden { display: none; }
        .num-input { 
            width: 100%; background: transparent; border: none; color: white; 
            text-align: right; font-family: monospace; outline: none; font-size: 11px; 
        }
        .keypad { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: auto; flex-shrink: 0; }
        .key-btn {
            background: #333; color: white; border: 1px solid #444; padding: 8px 0;
            border-radius: 4px; font-weight: bold; cursor: pointer; user-select: none;
            font-family: monospace; font-size: 13px; text-align: center; transition: background 0.1s;
        }
        .calc-action-btn {
            background: #2a2a30; border: 1px solid #444; color: #ccc;
            padding: 8px 0; border-radius: 4px; cursor: pointer; flex: 1;
            font-size: 11px; font-weight: bold; transition: all 0.2s;
            text-align: center; /* Maiuscolo rimosso */
        }
        .calc-action-btn:hover { background: #3a3a40; color: white; border-color: #0088ff; }
        .calc-action-btn:active { transform: scale(0.96); }

        .key-btn:hover { background: #3a3a3a; }
        .key-num { background: #1a1a1a; border-color: #333; color: #eee; }
        .key-op { background: #2a2a2a; }
        .key-eval { background: #008855; border-color: #00aa66; }
        .key-del { background: #662222; }

        #history-overlay {
            position: absolute; top: 50px; left: 0; right: 0; bottom: 0;
            background: rgba(20, 20, 25, 0.98); z-index: 100;
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; flex-direction: column; border-left: 1px solid #444;
        }
        #history-overlay.open { transform: translateX(0); }
        .history-header {
            padding: 10px; border-bottom: 1px solid #444; background: #25252a;
            display: flex; justify-content: space-between; align-items: center; font-size: 13px;
            color: white;
        }
        #calc-log { flex: 1; overflow-y: auto; padding: 10px; }
        .log-entry { 
            background: #1a1a1a; border: 1px solid #333; border-radius: 4px; 
            padding: 8px; margin-bottom: 8px; cursor: pointer; transition: 0.2s;
        }
        .log-entry:hover { border-color: #0088ff; background: #222; }
        .log-expr { color: #888; font-size: 11px; margin-bottom: 3px; }
        .log-res { color: #0f8; font-family: monospace; font-size: 12px; word-break: break-all; }

        /* --- 3D LABELS --- */
        .label {
            color: #fff; font-family: 'Times New Roman', serif; font-weight: bold;
            font-style: italic; font-size: 14px; text-shadow: 0 0 3px black;
            pointer-events: none; user-select: none;
        }

        /* --- FORMULA BUTTONS & HORIZONTAL RESIZER --- */
        #formula-container { 
            padding: 10px;
            background: #1b1b20; 
            flex: 1;
            overflow-y: auto;
            min-height: 50px;
        }
        
        #table-resizer {
            height: 16px;
            width: 100%;
            background: #2a2a30;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            position: relative;
            touch-action: none;
            z-index: 10;
        }

        #table-resizer::after {
            content: '';
            width: 40px;
            height: 4px;
            background: #0088ff;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(0, 136, 255, 0.5);
        }

        #table-resizer:hover::after {
            background: #33aaff;
            width: 60px;
        }
        .formula-group-title { color: #888; font-size: 11px; margin-bottom: 5px; font-weight: bold; text-transform: uppercase; }
        .formula-btn {
            display: block; width: 100%; text-align: left;
            background: #25252a; color: #ddd;
            padding: 8px 10px; margin-bottom: 6px;
            border: 1px solid #444; border-radius: 4px;
            cursor: pointer; font-family: 'Times New Roman', serif; font-size: 13px; font-style: italic;
            transition: all 0.2s;
        }
        .formula-btn:hover { background: #333; border-color: #0088ff; color: white; transform: translateX(2px); }
        .formula-btn strong { font-family: 'Segoe UI', sans-serif; font-style: normal; font-size: 11px; color: #0088ff; margin-right: 5px; }

        /* --- HELP MODAL --- */
        #help-modal {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 3000;
            justify-content: center; align-items: center; backdrop-filter: blur(5px);
        }
        #help-modal.visible { display: flex; }
        .help-container {
            width: 500px; max-width: 90%; height: 400px;
            background: #25252b; border: 1px solid #555; border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            display: flex; flex-direction: column; overflow: hidden;
            position: relative;
        }
        .help-header {
            padding: 15px; border-bottom: 1px solid #444; background: #2a2a30;
            display: flex; justify-content: space-between; align-items: center; color: white;
        }
        .help-content { flex: 1; padding: 20px; color: #ddd; font-size: 14px; line-height: 1.6; overflow-y: auto; }
        .help-page { display: none; animation: fadeIn 0.3s; }
        .help-page.active { display: block; }
        .help-footer {
            padding: 10px 15px; border-top: 1px solid #444; background: #2a2a30;
            display: flex; justify-content: space-between; align-items: center;
        }
        .help-nav-btn {
            background: #444; color: white; border: none; padding: 8px 15px;
            border-radius: 6px; cursor: pointer; font-weight: bold;
        }
        .help-nav-btn:hover { background: #666; }
        .help-nav-btn:disabled { opacity: 0.3; cursor: default; }
        .help-indicators { display: flex; gap: 5px; }
        .help-dot { width: 8px; height: 8px; border-radius: 50%; background: #444; }
        .help-dot.active { background: #0088ff; }

        .help-icon-inline {
            display: inline-flex; align-items: center; justify-content: center;
            width: 20px; height: 20px; background: rgba(255,255,255,0.1); border: 1px solid #555;
            border-radius: 4px; font-size: 12px; vertical-align: middle; margin: 0 2px;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="help-modal">
        <div class="help-container">
            <div class="help-header">
                <strong>Guida all'uso</strong>
                <div id="close-help-btn" class="icon-btn" style="font-size:20px;">&times;</div>
            </div>
            <div class="help-content">
                
                <div class="help-page active" data-page="0">
                    <h3 style="color:#00aaff; margin-top:0;">1. Panoramica e Visualizzazione 3D</h3>
                    <p>Progetto ideato da <strong>Fabio Caiazzo</strong> ed √® stato realizzato con il supporto di strumenti di intelligenza artificiale, che hanno assistito nella scrittura del codice sulla base delle specifiche fornite dall'autore. Strumento per la visualizzazione di quaternioni, ottetti e sedenioni.</p>
                    <ul style="padding-left:20px;">
                        <li><strong>Grafico 3D:</strong> Mostra la struttura moltiplicativa. La disposizione degli elementi indica il prodotto.</li>
                        <li><strong>Verso Positivo:</strong> Il senso di percorrenza delle punte bianche sulle linee indica il verso positivo della moltiplicazione (es: se e_1*e_2=e_3, il punto segue 1-2-3).</li>
                        <li><strong>Interazione:</strong> Cliccando sulle singole unit√† immaginarie √® possibile isolare i cicli ad essi associati.</li>
                    </ul>
                </div>

                <div class="help-page" data-page="1">
                    <h3 style="color:#00aaff; margin-top:0;">2. Impostazioni e Selezione Algebra</h3>
                    <p><strong>Barra Impostazioni</strong> (<span class="help-icon-inline">‚öôÔ∏è</span>): Gestione ambiente.</p>
                    <ul style="padding-left:20px; margin-bottom:10px;">
                        <li><strong>Reset Vista:</strong> Riporta la visuale alla posizione originale (o premendo Invio).</li>
                        <li><strong>Sfondo:</strong> Cambia tra 5 varianti diverse.</li>
                        <li><strong>Animazione:</strong> Pausa/Riavvio (o premendo Space) e Slider velocit√† (o premendo le frecce < e >).</li>
                    </ul>
                    <p><strong>Selezione Algebra</strong> (Tasto <span class="help-icon-inline">&#x1D54A;</span>): Passa tra H, O, S.</p>
                    <ul style="padding-left:20px;">
                        <li><strong>Modifica Grafico:</strong> Circonferenza (H), Piano di Fano (O), PG(3,2) (S).</li>
                        <li><strong>Aggiorna:</strong> Cicli, Divisori Zero (solo S) e Tabella.</li>
                    </ul>
                </div>

                <div class="help-page" data-page="2">
                    <h3 style="color:#00aaff; margin-top:0;">3. Calcolatrice: Gestione Variabili</h3>
                    <p>Accessibile dal tasto <span class="help-icon-inline">üñ©</span> o da tastiera digitando caratteri. Permette calcoli sulle tre algebre.</p>
                    <ul style="padding-left:20px;">
                        <li><strong>Variabili (a, b, c, d):</strong> Si possono salvare fino a 4 variabili. La dimensione si adatta all'algebra (4, 8 o 16 valori).</li>
                        <li><strong>Tasti Rapidi:</strong>
                            <ul>
                                <li><em>"Azz Var"</em>: Pone la variabile a 0.</li>
                                <li><em>"Random Var"</em>: Genera coefficienti interi casuali tra -10 e 10.</li>
                            </ul>
                        </li>
                        <li><strong>Scalari:</strong> Numeri 0-9 per moltiplicazioni dirette.</li>
                    </ul>
                </div>

                <div class="help-page" data-page="3">
                    <h3 style="color:#00aaff; margin-top:0;">4. Calcolatrice: Operazioni</h3>
                    <ul style="padding-left:20px;">
                        <li><strong>Sintassi e Operazioni:</strong> Modulo (<code>|v|</code>), Inverso (<code>inv</code>), Coniugato (<code>cnj</code>), Commutatore/Associatore (<code>[x,y]</code>).</li>
                        <li><strong>Unit√† immaginarie:</strong> Tasto <code>e_(n)</code> per inserire le unit√† immaginarie.</li>
                        <li><strong>Punteggiatura:</strong> Tasto "." (punto decimale), Tasto "," (separatore argomenti).</li>
                        <li><strong>Cronologia</strong> (Tasto üïí):
                            <ul>
                                <li>Mostra/Nasconde risultati passati.</li>
                                <li>"Pulisci" per cancellare. Clicca "AnsX" per riutilizzare.</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="help-page" data-page="4">
                    <h3 style="color:#00aaff; margin-top:0;">5. Pannello Laterale (Tabelle)</h3>
                    <p>Apri con <span class="help-icon-inline">‚ñ¶</span>. Tre sezioni:</p>
                    <ul style="padding-left:20px;">
                        <li><strong>A. Cicli:</strong> Elenco cicli (1, 7 o 35). Clicca per isolare nel grafico. "Mostra tutto" per resettare.</li>
                        <li><strong>B. Divisori Zero:</strong> (Solo S) Clicca una coppia per caricarla in calcolatrice e verificare il prodotto nullo.</li>
                        <li><strong>C. Tabella:</strong> (Colonna Sx * Riga Alto).
                            <ul>
                                <li>Clic intestazione: Evidenzia riga/colonna.</li>
                                <li>Clic incrocio: Evidenzia risultato.</li>
                                <li>Clic cella interna: Evidenzia terna 3D corrispondente.</li>
                                <li>Propriet√† in basso: Clicca per esempio random.</li>
                            </ul>
                        </li>
                    </ul>
                </div>

            </div>
            <div class="help-footer">
                <button id="help-prev-btn" class="help-nav-btn" disabled>&lt; Indietro</button>
                <div class="help-indicators">
                    <div class="help-dot active"></div>
                    <div class="help-dot"></div>
                    <div class="help-dot"></div>
                    <div class="help-dot"></div>
                    <div class="help-dot"></div>
                </div>
                <button id="help-next-btn" class="help-nav-btn">Avanti &gt;</button>
            </div>
        </div>
    </div>

    <div id="calc-modal">
        <div class="calc-header">
            <div class="calc-mode-wrapper">
                <select id="calc-alg-select" class="calc-mode-sel" title="Seleziona Algebra">
                    <option value="3">Quaternioni (&#x210D;)</option>
                    <option value="7">Ottetti (&#x1D546;)</option>
                    <option value="15" selected>Sedenioni (&#x1D54A;)</option>
                </select>
            </div>
            
            <div class="header-actions">
                <div id="toggle-history-btn" class="icon-btn" title="Cronologia">üïí</div>
                <div id="close-calc" class="icon-btn" title="Chiudi" style="font-size: 22px;">&times;</div>
            </div>
        </div>
        
        <div id="history-overlay">
            <div class="history-header">
                <strong>Cronologia Risultati</strong>
                <span id="btn-clear-log" style="cursor:pointer; color:#ff5555;">üóëÔ∏è Pulisci</span>
            </div>
            <div id="calc-log">
                <div style="text-align:center; color:#555; margin-top:20px; font-size:12px;">Nessun calcolo recente</div>
            </div>
        </div>
    
        <div class="calc-body">
            <div class="display-area">
                <input type="text" id="expression-display" placeholder="Espressione..." autocomplete="off" inputmode="none">
                <div id="result-display">0</div>
            </div>
    
            <div class="var-tabs">
                <div class="var-tab active" data-var="a">Var A</div>
                <div class="var-tab" data-var="b">Var B</div>
                <div class="var-tab" data-var="c">Var C</div>
                <div class="var-tab" data-var="d">Var D</div>
            </div>
    
            <div style="margin-bottom: 5px;">
                <div id="input-grid" class="vector-inputs"></div>
            </div>
            
            <div style="display:flex; justify-content:space-between; gap:5px; margin-bottom:8px; flex-shrink:0;">
                 <button class="calc-action-btn" id="btn-grid-clear">Azzera Var</button>
                 <button class="calc-action-btn" id="btn-grid-rand">Random Var</button>
            </div>
    
            <div class="keypad">
                <button class="key-btn key-var" onclick="calcInput('a')">a</button>
                <button class="key-btn key-var" onclick="calcInput('b')">b</button>
                <button class="key-btn key-var" onclick="calcInput('c')">c</button>
                <button class="key-btn key-var" onclick="calcInput('d')">d</button>
                <button class="key-btn key-var" onclick="calcInput('e_(')" title="Inserisci base">e<sub>n</sub></button>
                
                <button class="key-btn" onclick="calcInput('norm(')">|v|</button>
                <button class="key-btn" onclick="calcInput('inv(')">inv</button>
                <button class="key-btn" onclick="calcInput('conj(')">cnj</button>
                <button class="key-btn key-op" onclick="calcBracket()" title="Commutatore/Associatore">[x,y]</button>
                <button class="key-btn" onclick="calcSmartParen()">( )</button>
    
                <button class="key-btn key-num" onclick="calcInput('7')">7</button>
                <button class="key-btn key-num" onclick="calcInput('8')">8</button>
                <button class="key-btn key-num" onclick="calcInput('9')">9</button>
                <button class="key-btn key-op" onclick="calcInput(' + ')">+</button>
                <button class="key-btn key-del" onclick="calcAction('back')">‚å´</button>
    
                <button class="key-btn key-num" onclick="calcInput('4')">4</button>
                <button class="key-btn key-num" onclick="calcInput('5')">5</button>
                <button class="key-btn key-num" onclick="calcInput('6')">6</button>
                <button class="key-btn key-op" onclick="calcInput(' - ')">-</button>
                <button class="key-btn key-del" onclick="calcAction('clear')">AC</button>
    
                <button class="key-btn key-num" onclick="calcInput('1')">1</button>
                <button class="key-btn key-num" onclick="calcInput('2')">2</button>
                <button class="key-btn key-num" onclick="calcInput('3')">3</button>
                <button class="key-btn key-op" onclick="calcInput(' * ')">&times;</button>
                
                <button class="key-btn key-eval" onclick="calcAction('eval')" style="grid-row: span 2; height: 100%;">=</button>
    
                <button class="key-btn key-num" onclick="calcInput('0')">0</button>
                <button class="key-btn key-num" onclick="calcInput('.')">.</button>
                <button class="key-btn key-num" onclick="calcInput(',')">,</button>
                <button class="key-btn key-op" onclick="calcInput(' / ')" title="Divisione">/</button>
            </div>
        </div>
    </div>

    <div id="main-container">
        <div id="canvas-container">
            <div id="top-bar">
                <div class="bar-group">
                    <div id="settings-toggle-btn" class="ui-btn" title="Impostazioni">
                        <svg class="icon-svg" viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.06-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.06,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.43-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
                    </div>
                    <div id="settings-menu">
                        <div class="menu-grid">
                            <button id="home-btn" class="menu-btn" title="Reset Camera">
                                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                                <span>Reset Vista</span>
                            </button>
                            
                            <button id="help-btn-trigger" class="menu-btn" title="Apri Guida">
                                <svg viewBox="0 0 24 24"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"/></svg>
                                <span>Guida</span>
                            </button>
                            
                            <button id="theme-btn" class="menu-btn full-width" title="Cambia Sfondo">
                                <svg viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>
                                <span id="theme-label">Sfondo</span>
                            </button>
                        </div>

                        <div class="setting-row">
                            <button id="play-pause-btn" title="Play/Pausa">
                                <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                            </button>
                            <div style="display:flex; flex-direction:column; flex:1;">
                                <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                                    <span style="font-weight:600; font-size:10px; letter-spacing:0.5px;">VELOCIT√Ä</span>
                                    <span id="speed-val" style="font-size:10px; color:#0088ff;">0.3x</span>
                                </div>
                                <input type="range" id="speed-slider" min="0" max="2" step="0.1" value="0.3">
                            </div>
                        </div>
                    </div>
                </div>
                <h2 id="main-title">Sedenioni</h2>
                <div class="bar-group">
                    <div id="btn-alg-toggle" class="ui-btn" style="font-family:'Times New Roman'; font-weight:bold; font-size:22px; color:white;">&#x1D54A;</div>
                    <div id="calc-toggle-btn" class="ui-btn" title="Calcolatrice"><svg class="icon-svg" viewBox="0 0 24 24"><path d="M7,2H17A2,2 0 0,1 19,4V20A2,2 0 0,1 17,22H7A2,2 0 0,1 5,20V4A2,2 0 0,1 7,2M7,4V8H17V4H7M7,10V12H9V10H7M11,10V12H13V10H11M15,10V12H17V10H15M7,14V16H9V14H7M11,14V16H13V14H11M15,14V16H17V14H15M7,18V20H9V18H7M11,18V20H13V18H11M15,18V20H17V18H15Z" /></svg></div>
                    <div id="sidebar-toggle-btn" class="ui-btn" title="Menu Tabelle" style="font-size: 32px;">‚ñ¶</div>
                </div>
            </div>
        </div>
        <div id="sidebar">
            <div id="sidebar-resizer"></div> <div class="sidebar-tabs">
                <button class="tab-btn active" data-tab="triplets" id="tab-btn-triplets">Cicli (35)</button>
                <button class="tab-btn" data-tab="zerodiv" id="tab-btn-zerodiv">Divisori dello zero (84)</button>
                <button class="tab-btn" data-tab="table" id="tab-btn-table">Tabella</button>
                <button id="close-sidebar-btn" title="Chiudi">&times;</button>
            </div>
            <div id="tab-triplets" class="tab-content active">
                <div style="padding:10px; border-bottom:1px solid #444; display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;">
                    <div></div> 
                    <button id="sidebar-alg-toggle" style="background:transparent; border:1px solid #555; color:#eee; width:32px; height:32px; border-radius:6px; font-family:'Times New Roman'; font-weight:bold; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:0.2s;" title="Cambia Dimensione">
                        &#x1D54A;
                    </button>
                    <button id="show-all-btn" style="background:#008855; border:none; color:white; padding:6px 10px; border-radius:4px; cursor:pointer; font-size:11px; justify-self: end;">Mostra Tutto</button>
                </div>
                <div id="triplets-scroll"><div class="triplets-grid" id="buttons-container"></div></div>
            </div>
            <div id="tab-zerodiv" class="tab-content"><div id="zerodiv-scroll"><div id="zerodiv-grid"></div></div></div>
            <div id="tab-table" class="tab-content">
                <div style="padding:10px; border-bottom:1px solid #444; display:grid; grid-template-columns: 1fr auto 1fr; align-items:center;">
                     <div></div> 
                     <button id="sidebar-alg-toggle-table" style="background:transparent; border:1px solid #555; color:#eee; width:32px; height:32px; border-radius:6px; font-family:'Times New Roman'; font-weight:bold; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:0.2s;" title="Cambia Dimensione">
                        &#x1D54A;
                    </button>
                    <button id="show-all-table-btn" style="background:#008855; border:none; color:white; padding:6px 10px; border-radius:4px; cursor:pointer; font-size:11px; justify-self: end;">Mostra Tutto</button>
                </div>
                <div id="table-scroll"><table id="sedenion-table"></table></div>
                <div id="table-hint">Convenzione: Scegliere valore Colonna (Sx) &times; valore Riga (Alto).</div>
                <div id="table-resizer"></div>
                <div id="formula-container"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- DATI ---
        const POSITIVE_TRIPLETS = [
            [1, 2, 3], [1, 4, 5], [1, 7, 6], [1, 8, 9], [1, 11, 10], [1, 13, 12], [1, 14, 15],
            [2, 4, 6], [2, 5, 7], [2, 8, 10], [2, 9, 11], [2, 14, 12], [2, 15, 13], 
            [3, 4, 7], [3, 6, 5], [3, 8, 11], [3, 10, 9], [3, 13, 14], [3, 15, 12], 
            [4, 8, 12], [4, 9, 13], [4, 10, 14], [4, 11, 15], 
            [5, 8, 13], [5, 10, 15], [5, 12, 9], [5, 14, 11], 
            [6, 8, 14], [6, 11, 13], [6, 12, 10], [6, 15, 9], 
            [7, 8, 15], [7, 9, 14], [7, 12, 11], [7, 13, 10]
        ];
        
        const ZERO_DIVISORS_RAW = [
            [1,10,5,14], [1,10,4,-15], [1,10,7,12], [1,10,6,-13], [1,11,4,14], [1,11,6,-12], [1,11,5,15], [1,11,7,-13],
            [1,12,2,15], [1,12,3,-14], [1,12,6,11], [1,12,7,-10], [1,13,6,10], [1,13,2,-14], [1,13,7,11], [1,13,3,-15],
            [1,14,2,13], [1,14,4,-11], [1,14,3,12], [1,14,5,-10], [1,15,3,13], [1,15,2,-12], [1,15,4,10], [1,15,5,-11],
            [2,9,4,15],  [2,9,5,-14],  [2,9,6,13],  [2,9,7,-12], [2,11,5,12], [2,11,4,-13], [2,11,6,15], [2,11,7,-14],
            [2,12,3,13], [2,12,5,-11], [2,12,7,9],  [2,13,3,-12], [2,13,4,11], [2,13,6,-9],  [2,14,5,9],  [2,14,3,-15],
            [2,14,7,11], [2,15,4,-9],  [2,15,3,14], [2,15,6,-11], [3,9,6,12],  [3,9,4,-14],  [3,9,7,13],  [3,9,5,-15],
            [3,10,4,13], [3,10,5,-12], [3,10,7,14], [3,10,6,-15], [3,12,5,10], [3,12,6,-9],  [3,14,4,9],  [3,13,4,-10],
            [3,15,5,9],  [3,13,7,-9],  [3,15,6,10], [3,14,7,-10], [4,9,7,10],  [4,9,6,-11],  [4,10,5,11], [4,10,7,-9],
            [4,11,6,9],  [4,11,5,-10], [4,13,6,15], [4,13,7,-14], [4,14,7,13], [4,14,5,-15], [4,15,5,14], [4,15,6,-13],
            [5,10,6,9],  [5,9,6,-10],  [5,11,7,9],  [5,9,7,-11], [5,12,7,14], [5,12,6,-15], [5,15,6,12], [5,14,7,-12],
            [6,11,7,10], [6,10,7,-11], [6,13,7,12], [6,12,7,-13]
        ];

        const tableColors = {
            'black': {bg:'rgb(20,20,20)',fg:'white'}, 'marrone': {bg:'rgb(153,102,0)',fg:'black'}, 'rosso': {bg:'rgb(255,0,0)',fg:'black'},
            'arancione': {bg:'rgb(255,102,0)',fg:'black'}, 'ocra': {bg:'rgb(255,215,0)',fg:'black'}, 'giallo': {bg:'rgb(255,255,0)',fg:'black'},
            'verdechiaro': {bg:'rgb(0,255,0)',fg:'black'}, 'verde': {bg:'rgb(0,153,0)',fg:'black'}, 'verdescuro': {bg:'rgb(0,100,0)',fg:'white'},
            'viola': {bg:'rgb(127,0,255)',fg:'white'}, 'bluscuro': {bg:'rgb(0,0,204)',fg:'white'}, 'bluet': {bg:'rgb(51,51,255)',fg:'white'},
            'azzurro': {bg:'rgb(102,204,255)',fg:'black'}, 'violetto': {bg:'rgb(255,0,255)',fg:'black'}, 'fucsia': {bg:'rgb(255,102,153)',fg:'black'},
            'rosa': {bg:'rgb(255,192,203)',fg:'black'}
        };
        const indexToColorKey = ['black','marrone','rosso','arancione','ocra','giallo','verdechiaro','verde','verdescuro','viola','bluscuro','bluet','azzurro','violetto','fucsia','rosa'];

        const tableRaw = [
            ["1", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "e10", "e11", "e12", "e13", "e14", "e15"],
            ["e1", "-1", "e3", "-e2", "e5", "-e4", "-e7", "e6", "e9", "-e8", "-e11", "e10", "-e13", "e12", "e15", "-e14"],
            ["e2", "-e3", "-1", "e1", "e6", "e7", "-e4", "-e5", "e10", "e11", "-e8", "-e9", "-e14", "-e15", "e12", "e13"],
            ["e3", "e2", "-e1", "-1", "e7", "-e6", "e5", "-e4", "e11", "-e10", "e9", "-e8", "-e15", "e14", "-e13", "e12"],
            ["e4", "-e5", "-e6", "-e7", "-1", "e1", "e2", "e3", "e12", "e13", "e14", "e15", "-e8", "-e9", "-e10", "-e11"],
            ["e5", "e4", "-e7", "e6", "-e1", "-1", "-e3", "e2", "e13", "-e12", "e15", "-e14", "e9", "-e8", "e11", "-e10"],
            ["e6", "e7", "e4", "-e5", "-e2", "e3", "-1", "-e1", "e14", "-e15", "-e12", "e13", "e10", "-e11", "-e8", "e9"],
            ["e7", "-e6", "e5", "e4", "-e3", "-e2", "e1", "-1", "e15", "e14", "-e13", "-e12", "e11", "e10", "-e9", "-e8"],
            ["e8", "-e9", "-e10", "-e11", "-e12", "-e13", "-e14", "-e15", "-1", "e1", "e2", "e3", "e4", "e5", "e6", "e7"],
            ["e9", "e8", "-e11", "e10", "-e13", "e12", "e15", "-e14", "-e1", "-1", "-e3", "e2", "-e5", "e4", "e7", "-e6"],
            ["e10", "e11", "e8", "-e9", "-e14", "-e15", "e12", "e13", "-e2", "e3", "-1", "-e1", "-e6", "-e7", "e4", "e5"],
            ["e11", "-e10", "e9", "e8", "-e15", "e14", "-e13", "e12", "-e3", "-e2", "e1", "-1", "-e7", "e6", "-e5", "e4"],
            ["e12", "e13", "e14", "e15", "e8", "-e9", "-e10", "-e11", "-e4", "e5", "e6", "e7", "-1", "-e1", "-e2", "-e3"],
            ["e13", "-e12", "e15", "-e14", "e9", "e8", "e11", "-e10", "-e5", "-e4", "e7", "-e6", "e1", "-1", "e3", "-e2"],
            ["e14", "-e15", "-e12", "e13", "e10", "-e11", "e8", "e9", "-e6", "-e7", "-e4", "e5", "e2", "-e3", "-1", "e1"],
            ["e15", "e14", "-e13", "-e12", "e11", "e10", "-e9", "e8", "-e7", "e6", "-e5", "-e4", "e3", "e2", "-e1", "-1"]
        ];

        const palette = [0xff3333, 0xffaa00, 0xffff00, 0x00ff00, 0x00ffff, 0x0066ff, 0xaa00ff, 0xff00ff];

        // --- FUNZIONI TABELLA ---
        let tableState = { activeRow: null, activeCol: null };

        function getBaseIndex(valStr) {
            let s = valStr.replace('-', '');
            if (s === '1') return 0;
            return parseInt(s.substring(1));
        }

        function formatLatex(str) {
            if (str === '1' || str === '-1') return str;
            return str.replace(/e(\d+)/, 'e<sub>$1</sub>');
        }

        function activateTripletFromTable(r, c) {
            if(r === 0 || c === 0 || r === c) return;
            const tripletIdx = POSITIVE_TRIPLETS.findIndex(t => t.includes(r) && t.includes(c));
            if (tripletIdx !== -1) {
                const limit = parseInt(document.getElementById('calc-alg-select').value) || 15;
                const triplet = POSITIVE_TRIPLETS[tripletIdx];
                if(triplet.some(v => v > limit)) return;
                visualizeTripletByIndex(tripletIdx);
            }
        }

        // Funzione che gestisce la visualizzazione 3D basata sulla selezione Tabella
        function updateTableVis() {
            const r = tableState.activeRow;
            const c = tableState.activeCol;

            // 1. Nessuna selezione: Reset vista completa
            if (r === null && c === null) {
                resetView();
                return;
            }

            // 2. Doppia selezione (Riga E Colonna): Isola il ciclo comune
            if (r !== null && c !== null) {
                // Se sono uguali o coinvolgono l'identit√† (0), resetta o mostra solo i punti
                if (r === 0 || c === 0 || r === c) {
                    resetView(); 
                } else {
                    // Cerca la tripletta che contiene entrambi
                    const idx = POSITIVE_TRIPLETS.findIndex(t => t.includes(r) && t.includes(c));
                    if (idx !== -1) {
                        highlightSingleTriplet(idx);
                    } else {
                        // Se non formano un ciclo (es. Divisori Zero), nascondi le linee e mostra solo i due punti
                        tripletVisuals.forEach(t => { 
                            t.mesh.visible = false; 
                            if(t.hitMesh) t.hitMesh.visible = false; 
                        });
                        for(let k in pointObjects) {
                            const id = parseInt(k);
                            const visible = (id === r || id === c);
                            pointObjects[k].mesh.visible = visible;
                            pointObjects[k].label.visible = visible;
                        }
                    }
                }
                return;
            }

            // 3. Singola selezione (Solo Riga O Solo Colonna): Isola tutti i cicli connessi
            const val = (r !== null) ? r : c;
            if (val === 0) resetView(); // L'identit√† √® ovunque, resettiamo per non creare confusione
            else highlightConnections(val);
        }

        function buildTable(limitIndex) {
            const table = document.getElementById('sedenion-table');
            
            // OPTIMIZATION: Ricostruisci il DOM solo se cambia dimensione (cambio algebra)
            const neededRows = limitIndex + 2; // 1 header + (limitIndex+1) righe dati
            const needsRebuild = table.rows.length !== neededRows;

            if (needsRebuild) {
                table.innerHTML = ''; 
                const thead = document.createElement('tr');
                const corner = document.createElement('th');
                corner.innerHTML = "&times;"; 
                corner.classList.add("first-col");
                corner.onclick = () => { 
                    tableState.activeRow=null; 
                    tableState.activeCol=null; 
                    buildTable(limitIndex); 
                    updateTableVis(); 
                };
                thead.appendChild(corner);
                
                for(let i=0; i<=limitIndex; i++) {
                    const th = document.createElement('th');
                    th.innerHTML = i === 0 ? "1" : "e<sub>" + i + "</sub>";
                    th.onclick = () => { 
                        tableState.activeCol = (tableState.activeCol === i) ? null : i; 
                        buildTable(limitIndex); 
                        updateTableVis(); 
                    };
                    thead.appendChild(th);
                }
                table.appendChild(thead);

                for(let r=0; r<=limitIndex; r++) {
                    const tr = document.createElement('tr');
                    const thRow = document.createElement('td');
                    thRow.innerHTML = r === 0 ? "1" : "e<sub>" + r + "</sub>";
                    thRow.classList.add("first-col");
                    thRow.onclick = () => { 
                        tableState.activeRow = (tableState.activeRow === r) ? null : r; 
                        buildTable(limitIndex); 
                        updateTableVis(); 
                    };
                    tr.appendChild(thRow);

                    for(let c=0; c<=limitIndex; c++) {
                        const td = document.createElement('td');
                        const val = tableRaw[r][c];
                        const style = tableColors[indexToColorKey[getBaseIndex(val)]];
                        td.innerHTML = formatLatex(val);
                        td.style.backgroundColor = style.bg;
                        td.style.color = style.fg;
                        td.onclick = () => activateTripletFromTable(r, c);
                        tr.appendChild(td);
                    }
                    table.appendChild(tr);
                }
            }

            // AGGIORNAMENTO CLASSI (Veloce, senza toccare innerHTML)
            // 1. Pulisci tutto
            table.querySelectorAll('.header-active, .table-intersect, .table-highlight').forEach(el => {
                el.classList.remove('header-active', 'table-intersect', 'table-highlight');
            });

            // 2. Applica Highlight Header Colonna
            if (tableState.activeCol !== null) {
                if(table.rows[0].cells[tableState.activeCol + 1])
                    table.rows[0].cells[tableState.activeCol + 1].classList.add('header-active');
            }

            // 3. Applica Highlight Righe e Celle
            for(let r=0; r<=limitIndex; r++) {
                const tr = table.rows[r+1];
                if(!tr) continue;

                // Header Riga
                if (r === tableState.activeRow) {
                    tr.cells[0].classList.add('header-active');
                }

                for(let c=0; c<=limitIndex; c++) {
                    const td = tr.cells[c+1];
                    if(!td) continue;

                    if (tableState.activeRow !== null || tableState.activeCol !== null) {
                        const rowMatch = (tableState.activeRow === r);
                        const colMatch = (tableState.activeCol === c);
                        if (rowMatch && colMatch) td.classList.add('table-intersect');
                        else if (!rowMatch && !colMatch) td.classList.add('table-highlight');
                    }
                }
            }
        }


        // --- 3D SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        const initialCameraPos = new THREE.Vector3(14, 12, 24);
        camera.position.copy(initialCameraPos);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);
        
        // --- FIX ZOOM LIMITS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 2; // Evita di entrare nelle sfere
        controls.maxDistance = 150; // Evita di perdere il grafico nel vuoto

	controls.target.set(0, 3, 0); 
        controls.update();

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- GEOMETRIA ---
        const S = 12.0; 
        const h_tri = S * Math.sqrt(3) / 2;       
        const r_center = h_tri / 3;               
        const R_vertex = h_tri * 2 / 3;           
        const H_pyr = S * Math.sqrt(2 / 3);       
        const v_e5 = new THREE.Vector3(-S/2, 0, r_center);   
        const v_e6 = new THREE.Vector3( S/2, 0, r_center);    
        const v_e7 = new THREE.Vector3(0, 0, -R_vertex);   
        const v_e12 = new THREE.Vector3(0, H_pyr, 0);   
        const mid = (v1, v2) => new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
        const centroid3 = (v1, v2, v3) => new THREE.Vector3().addVectors(v1, v2).add(v3).divideScalar(3);
        const pts = {};
        pts[5] = v_e5; pts[6] = v_e6; pts[7] = v_e7; pts[12] = v_e12; 
        pts[3] = mid(v_e5, v_e6); pts[2] = mid(v_e5, v_e7); pts[1] = mid(v_e6, v_e7);
        pts[4] = centroid3(v_e5, v_e6, v_e7);
        pts[9] = mid(v_e5, v_e12); pts[10] = mid(v_e6, v_e12); pts[15] = centroid3(v_e5, v_e6, v_e12);
        pts[11] = mid(v_e7, v_e12); pts[14] = centroid3(v_e12, v_e5, v_e7);
        pts[13] = centroid3(v_e6, v_e7, v_e12);
        pts[8] = new THREE.Vector3().addVectors(v_e5, v_e6).add(v_e7).add(v_e12).multiplyScalar(0.25);

        const pointObjects = {}; 
        // OTTIMIZZAZIONE: Ridotti segmenti da 16 a 10/8 (molto pi√π leggero per 16 sfere)
        const sphereGeom = new THREE.SphereGeometry(0.22, 10, 8); 
        const sphereMat = new THREE.MeshPhysicalMaterial({ color: 0xaaaaaa, metalness: 0.2, roughness: 0.4 });
        const sphereMatCenter = new THREE.MeshPhysicalMaterial({ color: 0xffdd00, metalness: 0.2, roughness: 0.4 });

        Object.keys(pts).forEach(k => {
            const idx = parseInt(k);
            const mesh = new THREE.Mesh(sphereGeom, idx===8 ? sphereMatCenter : sphereMat);
            mesh.position.copy(pts[k]);
            scene.add(mesh);
            const div = document.createElement('div');
            div.className = 'label';
            div.innerHTML = 'e<sub>' + idx + '</sub>';
            const label = new CSS2DObject(div);
            label.position.set(0, 0.4, 0);
            mesh.add(label);
            pointObjects[idx] = { mesh, label };
        });

        // --- SHADER PATHS ---
        const flowVertexShader = `
            precision mediump float;
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const flowFragmentShader = `
            uniform vec3 color; uniform float customTime; uniform float flowDir; varying vec2 vUv;
            void main() {
                float t = customTime; float uvX = (flowDir > 0.0) ? vUv.x : (1.0 - vUv.x);
                float progress = fract(uvX - t); float head = smoothstep(0.8, 1.0, progress); 
                float tail = pow(progress, 3.0); vec3 finalRGB = mix(color * 0.1, color, tail);
                finalRGB = mix(finalRGB, vec3(1.0), head); gl_FragColor = vec4(finalRGB, 1.0);
            }
        `;
        const animatedMaterials = [];
        const tripletVisuals = [];
        const animParams = { speed: 0.3, paused: false, customTime: 0 };

        function createTripletPath(triplet, colorHex) {
            const [i1, i2, i3] = triplet;
            const p1 = pts[i1], p2 = pts[i2], p3 = pts[i3];
            let curve;
            let isOpenCurve = false;
            const v12 = new THREE.Vector3().subVectors(p2, p1);
            const v13 = new THREE.Vector3().subVectors(p3, p1);
            const normal = new THREE.Vector3().crossVectors(v12, v13);
            const isCollinear = normal.lengthSq() < 0.001;

            if (isCollinear) {
                // FIX: Usa LineCurve3 per linee rette perfette ed evita artefatti grafici
                isOpenCurve = true;
                const d12 = p1.distanceTo(p2); const d23 = p2.distanceTo(p3); const d31 = p3.distanceTo(p1);
                
                // Crea una linea diretta tra i due estremi pi√π lontani
                if (d12 >= d23 && d12 >= d31) curve = new THREE.LineCurve3(p1, p2);
                else if (d23 >= d12 && d23 >= d31) curve = new THREE.LineCurve3(p2, p3);
                else curve = new THREE.LineCurve3(p3, p1);
                
            } else {
                isOpenCurve = false;
                let points = [];
                const axisZ = normal.normalize(); 
                const v1 = new THREE.Vector3().subVectors(p2, p1);
                const v2 = new THREE.Vector3().subVectors(p3, p1);
                const v1xv2 = new THREE.Vector3().crossVectors(v1, v2);
                const lenSq = v1xv2.lengthSq();
                const centerOffset = new THREE.Vector3().addVectors(v2.clone().multiplyScalar(v1.lengthSq()).cross(v1xv2), v1xv2.clone().cross(v1.clone().multiplyScalar(v2.lengthSq()))).divideScalar(2 * lenSq);
                const Center = new THREE.Vector3().addVectors(p1, centerOffset);
                const Radius = centerOffset.length();
                const axisX = new THREE.Vector3().subVectors(p1, Center).normalize();
                const axisY = new THREE.Vector3().crossVectors(axisZ, axisX).normalize();
                for(let i=0; i<=64; i++) {
                    const theta = (i / 64) * Math.PI * 2;
                    points.push(new THREE.Vector3().copy(Center).add(axisX.clone().multiplyScalar(Radius * Math.cos(theta))).add(axisY.clone().multiplyScalar(Radius * Math.sin(theta))));
                }
                curve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
            }
            // OTTIMIZZAZIONE: Segmenti ridotti da 256->64 e raggio da 8->4. Risparmio memoria GPU enorme.
            const tubeGeom = new THREE.TubeGeometry(curve, 64, 0.035, 4, !isOpenCurve);
            const material = new THREE.ShaderMaterial({
                uniforms: { customTime: { value: 0 }, color: { value: new THREE.Color(colorHex) }, flowDir: { value: isCollinear ? -1.0 : 1.0 } },
                vertexShader: flowVertexShader, fragmentShader: flowFragmentShader,
                transparent: true, depthWrite: false, depthTest: true, side: THREE.FrontSide, blending: THREE.AdditiveBlending
            });
            animatedMaterials.push(material);
            const mesh = new THREE.Mesh(tubeGeom, material);
            scene.add(mesh);

            // HITBOX: Geometria super low-poly per il rilevamento mouse
            const hitGeom = new THREE.TubeGeometry(curve, 32, 0.25, 3, !isOpenCurve); 
            // Materiale trasparente (opacity: 0)
            const hitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, depthWrite: false });
            const hitMesh = new THREE.Mesh(hitGeom, hitMat);
            scene.add(hitMesh);

            tripletVisuals.push({ ids: triplet, mesh: mesh, hitMesh: hitMesh, color: colorHex, isCollinear: isCollinear });
        }
        POSITIVE_TRIPLETS.forEach((triplet, idx) => createTripletPath(triplet, palette[idx % palette.length]));

        // --- UI LOGIC ---
        const titleElem = document.getElementById('main-title');
        const tripletButtons = [];
        const btnAlgToggle = document.getElementById('btn-alg-toggle');
        const sidebarAlgToggle = document.getElementById('sidebar-alg-toggle');
        const sidebarAlgToggleTable = document.getElementById('sidebar-alg-toggle-table'); // Nuovo bottone tabella
        let currentAlgState = 15;

	// --- FORMULA DEMO LOGIC ---
        window.runFormulaDemo = function(alg, expr, vars) {
            // 1. Apri e Configura Calcolatrice
            openCalculator();
            calcAlgSelect.value = alg;
            updateGridVisibility();
            
            // 2. Genera Variabili Random (solo per quelle richieste)
            vars.forEach(vName => {
                switchVar(vName);
                const v = createZeroVector();
                // Random tra -10 e 10
                for(let i=0; i<=alg; i++) v[i] = Math.floor(Math.random() * 21) - 10;
                setGrid(v); 
                saveVar(vName);
            });

            // 3. Imposta l'espressione e calcola
            const disp = document.getElementById('expression-display');
            disp.value = expr;
            calcAction('eval'); // Esegue il calcolo
        };

        function updateAlgebraState(forcedState) {
            if (forcedState) currentAlgState = forcedState;
            else {
                if (currentAlgState === 3) currentAlgState = 7;
                else if (currentAlgState === 7) currentAlgState = 15;
                else currentAlgState = 3;
            }
            
            // Determina il simbolo corretto
            let symbol = "";
            if (currentAlgState === 3) symbol = "&#x210D;";       // H
            else if (currentAlgState === 7) symbol = "&#x1D546;"; // O
            else symbol = "&#x1D54A;";                            // S

            // Aggiorna tutti i pulsanti (Top Bar e Sidebar)
            btnAlgToggle.innerHTML = symbol;
            if(sidebarAlgToggle) sidebarAlgToggle.innerHTML = symbol;
            if(sidebarAlgToggleTable) sidebarAlgToggleTable.innerHTML = symbol;

            filterSubspace(currentAlgState);
            
            // Forza render (per la versione ottimizzata)
            if(typeof forceUpdate === 'function') forceUpdate();
        }
        
        filterSubspace(15);
        btnAlgToggle.addEventListener('click', () => updateAlgebraState(null));
        if(sidebarAlgToggle) sidebarAlgToggle.addEventListener('click', () => updateAlgebraState(null));
        if(sidebarAlgToggleTable) sidebarAlgToggleTable.addEventListener('click', () => updateAlgebraState(null));

        // --- GESTIONE COLORI CICLI (Tema Geometrico Fisso) ---
        const TETRA_VERTICES = [5, 6, 7, 12];
        const MIDPOINTS = [1, 2, 3, 9, 10, 11];

        function updateCycleColors() {
            tripletVisuals.forEach((t, i) => {
                let newColorHex;
                
                const hasCenter = t.ids.includes(8);
                
                if (hasCenter) {
                    // 4. Segmenti passanti per e8 (centro) -> Azzurri (Cyan)
                    newColorHex = 0x00ffff;
                } else if (!t.isCollinear) {
                    // Logica CERCHI (Curve):
                    // Solo i 4 cerchi sulle facce (composti esclusivamente da punti medi) sono ROSA
                    const isFaceCircle = t.ids.every(id => MIDPOINTS.includes(id));
                    
                    if (isFaceCircle) {
                        newColorHex = 0xff00ff; // Rosa
                    } else {
                        newColorHex = 0x00ff00; // Gli altri cerchi -> Verdi
                    }
                } else {
                    // Logica SEGMENTI (Linee):
                    const verticesCount = t.ids.filter(id => TETRA_VERTICES.includes(id)).length;
                    
                    if (verticesCount >= 2) {
                        // 1. Spigoli del tetraedro -> Rossi (Modificato da Arancione)
                        newColorHex = 0xff0000;
                    } else if (verticesCount === 1) {
                        // 2. Segmenti sulle facce -> Gialli
                        newColorHex = 0xffff00;
                    } else {
                        // 5. Restanti segmenti -> Verdi
                        newColorHex = 0x00ff00;
                    }
                }
                
                // Applica il colore
                t.mesh.material.uniforms.color.value.setHex(newColorHex);
                // Aggiorna anche il bordo del bottone nella sidebar
                if(tripletButtons[i]) tripletButtons[i].style.borderLeftColor = '#' + newColorHex.toString(16).padStart(6,'0');
            });
            if(typeof forceUpdate === 'function') forceUpdate();
        }
        

        function filterSubspace(limitIndex) {
            if(limitIndex===3) titleElem.innerText = "Quaternioni";
            else if(limitIndex===7) titleElem.innerText = "Ottetti";
            else titleElem.innerText = "Sedenioni";

            let tripletCount = 35; // Default Sedenioni
            if (limitIndex === 3) tripletCount = 1;      // Quaternioni
            if (limitIndex === 7) tripletCount = 7;      // Ottetti
            
            document.getElementById('tab-btn-triplets').innerText = `Cicli (${tripletCount})`;

	    const size = limitIndex + 1;
            const tabTable = document.getElementById('tab-btn-table');
            if(tabTable) tabTable.innerText = `Tabella (${size}√ó${size})`;

            for (let idStr in pointObjects) {
                const id = parseInt(idStr);
                const visible = id <= limitIndex;
                pointObjects[id].mesh.visible = visible;
                pointObjects[id].label.visible = visible;
            }
            tripletVisuals.forEach((t, i) => {
                const isVisible = t.ids.every(val => val <= limitIndex);
                t.mesh.visible = isVisible;
                if(t.hitMesh) t.hitMesh.visible = isVisible; // Nascondi anche la hitbox
                if(tripletButtons[i]) tripletButtons[i].style.display = isVisible ? 'block' : 'none';
            });
            tableState.activeRow = null; tableState.activeCol = null;
            buildTable(limitIndex);
            
            const zdBtn = document.getElementById('tab-btn-zerodiv');
            if(limitIndex < 15) {
                zdBtn.style.display = 'none';
                if(zdBtn.classList.contains('active')) document.getElementById('tab-btn-triplets').click();
            } else {
                zdBtn.style.display = 'block';
            }

            // --- INIEZIONE FORMULE ---
            const fContainer = document.getElementById('formula-container');
            fContainer.innerHTML = '';
            
            if (limitIndex === 3) { // Quaternioni
                fContainer.innerHTML = `
                    <div class="formula-group-title">In generale:</div>
                    <button class="formula-btn" onclick="runFormulaDemo(3, '[a,b]', ['a','b'])">
                        [a,b] = a*b - b*a &ne; 0
                    </button>
                `;
            } else if (limitIndex === 7) { // Ottetti
                fContainer.innerHTML = `
                    <div class="formula-group-title">In generale:</div>
                    <button class="formula-btn" onclick="runFormulaDemo(7, '[a,b,c]', ['a','b','c'])">
                        [a,b,c] = (a*b)*c - a*(b*c) &ne; 0
                    </button>
                `;
            } else if (limitIndex === 15) { // Sedenioni
                fContainer.innerHTML = `
                    <div class="formula-group-title">In generale:</div>
                    <button class="formula-btn" onclick="runFormulaDemo(15, '[a,a,b]', ['a','b'])">
                        [a,a,b] = (a*a)*b - a*(a*b) &ne; 0
                    </button>
                    <button class="formula-btn" onclick="runFormulaDemo(15, '[b,a,a]', ['a','b'])">
                        [b,a,a] = (b*a)*a - b*(a*a) &ne; 0
                    </button>
                    <div class="formula-group-title" style="margin-top:10px;">Ma (Flessibilit√†):</div>
                    <button class="formula-btn" onclick="runFormulaDemo(15, '[a,b,a]', ['a','b'])">
                        [a,b,a] = (a*b)*a - a*(b*a) = 0
                    </button>
                `;
            }
        }

        const settingsToggle = document.getElementById('settings-toggle-btn');
        const settingsMenu = document.getElementById('settings-menu');
        settingsToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            settingsMenu.classList.toggle('visible');
            settingsToggle.classList.toggle('active');
        });
        document.addEventListener('click', (e) => {
            if(!settingsMenu.contains(e.target) && e.target !== settingsToggle) {
                settingsMenu.classList.remove('visible');
                settingsToggle.classList.remove('active');
            }
        });

        const speedLabel = document.getElementById('speed-val');
        document.getElementById('speed-slider').addEventListener('input', (e) => {
            animParams.speed = parseFloat(e.target.value);
            if(speedLabel) speedLabel.innerText = animParams.speed + 'x';
        });

        document.getElementById('home-btn').addEventListener('click', () => { 
            // 1. Ferma l'inerzia dei controlli
            controls.enableDamping = false;
            controls.update();

            // 2. Resetta posizioni
            camera.position.copy(initialCameraPos); 
            controls.target.set(0,3,0); 
            
            // 3. Applica i cambiamenti e riabilita inerzia
            controls.update();
            controls.enableDamping = true;

            // 4. Forza render
            if(typeof forceUpdate === 'function') forceUpdate();
        });

        const playBtn = document.getElementById('play-pause-btn');
        // Icone SVG costanti
        const iconPlay = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'; // Triangolo
        const iconPause = '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>'; // Barre

        playBtn.addEventListener('click', () => {
            animParams.paused = !animParams.paused;
            // Scambia l'icona interna invece del testo
            playBtn.innerHTML = animParams.paused ? iconPlay : iconPause;
            // Se riprendiamo, forza il render loop
            if(!animParams.paused && typeof forceUpdate === 'function') forceUpdate();
        });
        
        let currentTheme = 0;
        const themeNames = ["Default", "Deep Space", "Studio Light", "Griglia Tecnica", "Stellato"];
        const themeBtn = document.getElementById('theme-btn');
        const themeLabel = document.getElementById('theme-label');
        
        const gridHelper = new THREE.GridHelper(60, 30, 0x444444, 0x111111); gridHelper.visible = false; gridHelper.position.y = -8; scene.add(gridHelper);
        const starsCount = 1000; const starsGeo = new THREE.BufferGeometry(); const starsPos = new Float32Array(starsCount*3);
        for(let i=0; i<starsCount*3; i++) starsPos[i] = (Math.random()-0.5)*100;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos,3));
        const starField = new THREE.Points(starsGeo, new THREE.PointsMaterial({size:0.15, color:0xffffff})); starField.visible=false; scene.add(starField);

        themeBtn.addEventListener('click', () => {
            currentTheme = (currentTheme + 1) % 5;
            
            // Aggiorna l'etichetta del pulsante
            themeLabel.innerText = "Sfondo: " + themeNames[currentTheme];

            scene.background = null; gridHelper.visible = false; starField.visible = false; 
            container.className = ''; scene.fog = null;
            container.style.background = ''; 

            if(currentTheme === 0) { 
                const col = 0x1a1a1a;
                scene.background = new THREE.Color(col); 
                container.style.backgroundColor = '#' + col.toString(16);
            }
            else if(currentTheme === 1) { 
                container.classList.add('bg-deep-space'); 
                scene.fog = new THREE.FogExp2(0x101020, 0.015); 
            }
            else if(currentTheme === 2) { 
                container.classList.add('bg-studio'); 
            }
            else if(currentTheme === 3) { 
                const col = 0x181818;
                scene.background = new THREE.Color(col); 
                gridHelper.visible = true; 
                container.style.backgroundColor = '#' + col.toString(16);
            }
            else if(currentTheme === 4) { 
                const col = 0x0a0a14;
                scene.background = new THREE.Color(col); 
                starField.visible = true; 
                container.style.backgroundColor = '#' + col.toString(16).padStart(6, '0');
            }
            
            // Forza render dopo il cambio tema (per la versione ottimizzata)
            if(typeof forceUpdate === 'function') forceUpdate();
        });

        // Sidebar
        // Sidebar & Resizer
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle-btn');
        const sidebarClose = document.getElementById('close-sidebar-btn');
        const resizer = document.getElementById('sidebar-resizer');

        function toggleSidebar() {
            // Reset larghezza manuale per permettere l'animazione CSS standard
            sidebar.style.width = ''; 
            sidebar.classList.toggle('open');
            sidebarToggle.classList.toggle('active');
            setTimeout(() => {
                const w = container.clientWidth; const h = container.clientHeight;
                camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); labelRenderer.setSize(w, h);
            }, 350);
        }

        sidebarToggle.addEventListener('click', toggleSidebar);
        sidebarClose.addEventListener('click', () => { 
            sidebar.classList.remove('open'); 
            sidebarToggle.classList.remove('active'); 
            sidebar.style.width = ''; // Reset

            // FIX: Forza il ricalcolo delle dimensioni 3D dopo l'animazione di chiusura
            setTimeout(() => {
                const w = container.clientWidth; const h = container.clientHeight;
                camera.aspect = w / h; camera.updateProjectionMatrix(); 
                renderer.setSize(w, h); labelRenderer.setSize(w, h);
            }, 350);
        });

        // Logica Resize (Trascinamento Mouse + Touch)
        let isResizing = false;

        function startResize(e) {
            isResizing = true;
            resizer.classList.add('active');
            sidebar.style.transition = 'none';
            document.body.style.cursor = 'ew-resize';
            if(e.type === 'mousedown') e.preventDefault(); 
        }

        function doResize(clientX) {
            if (!isResizing) return;
            const newWidth = window.innerWidth - clientX;
            
            if (newWidth < 50) { // Soglia ridotta per mobile
                sidebar.style.width = '0px';
            } else {
                sidebar.style.width = newWidth + 'px';
                if(!sidebar.classList.contains('open')) {
                     sidebar.classList.add('open');
                     sidebarToggle.classList.add('active');
                }
            }
        }

        function stopResize() {
            if (!isResizing) return;
            isResizing = false;
            resizer.classList.remove('active');
            sidebar.style.transition = ''; 
            document.body.style.cursor = 'default';

            if (parseInt(sidebar.style.width) === 0 || (sidebar.offsetWidth < 50)) {
                sidebar.classList.remove('open');
                sidebarToggle.classList.remove('active');
                sidebar.style.width = '';
            }
            
            const w = container.clientWidth; const h = container.clientHeight;
            camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); labelRenderer.setSize(w, h);
        }

        // Mouse Events
        resizer.addEventListener('mousedown', startResize);
        document.addEventListener('mousemove', (e) => doResize(e.clientX));
        document.addEventListener('mouseup', stopResize);

        // Touch Events (Nuovi)
        resizer.addEventListener('touchstart', (e) => {
            startResize(e);
            e.preventDefault(); // Previene lo scroll della pagina mentre afferri
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            if(isResizing) e.preventDefault(); // Previene scroll pagina
            doResize(e.touches[0].clientX);
        }, {passive: false});

        document.addEventListener('touchend', stopResize);

        const tabs = document.querySelectorAll('.tab-btn');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                if(tab.id === 'close-sidebar-btn') return;
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });

        function visualizeTripletByIndex(idx) {
            document.querySelectorAll('.triplet-btn').forEach(b => b.classList.remove('active'));
            if(tripletButtons[idx]) tripletButtons[idx].classList.add('active');
            const triplet = POSITIVE_TRIPLETS[idx];
            tripletVisuals.forEach((t, i) => {
                const isTarget = (i === idx);
                t.mesh.visible = isTarget;
                if(t.hitMesh) t.hitMesh.visible = isTarget;
            });
            for(let idStr in pointObjects) {
                const id = parseInt(idStr);
                const obj = pointObjects[id];
                const inTriplet = triplet.includes(id);
                obj.mesh.visible = inTriplet; 
                obj.label.visible = inTriplet;
            }
        }

        const buttonsContainer = document.getElementById('buttons-container');
        POSITIVE_TRIPLETS.forEach((triplet, idx) => {
            const btn = document.createElement('div');
            btn.className = 'triplet-btn';
            btn.innerText = `{${triplet[0]}, ${triplet[1]}, ${triplet[2]}}`;
            const hex = tripletVisuals[idx].color.toString(16).padStart(6,'0');
            btn.style.borderLeft = `4px solid #${hex}`;
            // FIX: Aggiunto l'evento click mancante
            btn.addEventListener('click', () => visualizeTripletByIndex(idx)); 
            buttonsContainer.appendChild(btn);
            tripletButtons.push(btn);
        });
        const resetView = () => {
            document.querySelectorAll('.triplet-btn').forEach(b => b.classList.remove('active'));
            filterSubspace(currentAlgState);
        };

        document.getElementById('show-all-btn').addEventListener('click', resetView);
        document.getElementById('show-all-table-btn').addEventListener('click', resetView);

        const zdContainer = document.getElementById('zerodiv-grid');
        ZERO_DIVISORS_RAW.forEach(zd => {
            const btn = document.createElement('div');
            btn.className = 'zerodiv-btn';
            const a = `(e<sub>${zd[0]}</sub>+e<sub>${zd[1]}</sub>)`;
            const sign1 = zd[2] < 0 ? "-" : ""; const sign2 = zd[3] < 0 ? "-" : "+";
            const b = `(${sign1}e<sub>${Math.abs(zd[2])}</sub>${sign2}e<sub>${Math.abs(zd[3])}</sub>)`;
            btn.innerHTML = a + b;
            btn.addEventListener('click', () => {
                openCalculator();
                saveVar(currentVar); switchVar('a'); setGrid(createZeroVector()); 
                const inputs = document.querySelectorAll('#input-grid input');
                inputs[zd[0]].value = 1; inputs[zd[1]].value = 1;
                saveVar('a'); switchVar('b'); setGrid(createZeroVector());
                inputs[Math.abs(zd[2])].value = Math.sign(zd[2]); inputs[Math.abs(zd[3])].value = Math.sign(zd[3]);
                saveVar('b');
                document.getElementById('expression-display').value = 'a * b';
                calcAction('eval');
            });
            zdContainer.appendChild(btn);
        });

        // Help Modal
        const helpModal = document.getElementById('help-modal');
        const helpBtnTrigger = document.getElementById('help-btn-trigger');
        const closeHelpBtn = document.getElementById('close-help-btn');
        const helpNext = document.getElementById('help-next-btn');
        const helpPrev = document.getElementById('help-prev-btn');
        const helpPages = document.querySelectorAll('.help-page');
        const helpDots = document.querySelectorAll('.help-dot');
        let currentHelpPage = 0;

        function updateHelpUI() {
            helpPages.forEach((p, i) => p.classList.toggle('active', i === currentHelpPage));
            helpDots.forEach((d, i) => d.classList.toggle('active', i === currentHelpPage));
            helpPrev.disabled = currentHelpPage === 0;
            helpNext.innerText = currentHelpPage === helpPages.length - 1 ? "Chiudi" : "Avanti >";
        }
        helpBtnTrigger.addEventListener('click', () => {
            helpModal.classList.add('visible');
            settingsMenu.classList.remove('visible'); settingsToggle.classList.remove('active');
            currentHelpPage = 0; updateHelpUI();
        });
        closeHelpBtn.addEventListener('click', () => helpModal.classList.remove('visible'));
        helpNext.addEventListener('click', () => {
            if(currentHelpPage < helpPages.length - 1) { currentHelpPage++; updateHelpUI(); } else { helpModal.classList.remove('visible'); }
        });
        helpPrev.addEventListener('click', () => { if(currentHelpPage > 0) { currentHelpPage--; updateHelpUI(); } });
        helpModal.addEventListener('click', (e) => { if(e.target === helpModal) helpModal.classList.remove('visible'); });


        // =============================================================
        // ===================== ADVANCED CALCULATOR ===================
        // =============================================================

        const calcModal = document.getElementById('calc-modal');
        const calcToggle = document.getElementById('calc-toggle-btn');
        const calcClose = document.getElementById('close-calc');
        const inputGrid = document.getElementById('input-grid');
        const calcAlgSelect = document.getElementById('calc-alg-select');
        
        let storedVars = {
            a: new Array(16).fill(0), b: new Array(16).fill(0), c: new Array(16).fill(0),
            d: new Array(16).fill(0)
        };
        let storedAns = []; 
        let currentVar = 'a';

        function createZeroVector() { return new Array(16).fill(0); }
        function vecAdd(v1, v2) { return v1.map((x, i) => x + v2[i]); }
        function vecSub(v1, v2) { return v1.map((x, i) => x - v2[i]); }
        function vecScale(v, s) { return v.map(x => x * s); }
        function vecNormSq(v) { return v.reduce((sum, x) => sum + x*x, 0); }
        function vecNorm(v) { const n = Math.sqrt(vecNormSq(v)); const res = createZeroVector(); res[0] = n; return res; }
        function vecConj(v) { return v.map((x, i) => i === 0 ? x : -x); }
        function vecInv(v) {
            const n2 = vecNormSq(v);
            if(n2 < 1e-9) throw "Divisione per zero";
            return vecScale(vecConj(v), 1/n2);
        }
        function vecMul(A, B) {
            const res = createZeroVector();
            for(let i=0; i<16; i++) {
                if(Math.abs(A[i]) < 1e-9) continue;
                for(let j=0; j<16; j++) {
                    if(Math.abs(B[j]) < 1e-9) continue;
                    const cell = tableRaw[i][j];
                    const sign = cell.startsWith('-') ? -1 : 1;
                    const idx = getBaseIndex(cell);
                    res[idx] += A[i] * B[j] * sign;
                }
            }
            return res;
        }

        // Commutator: [a,b] = ab - ba
        function vecComm(a, b) {
            return vecSub(vecMul(a, b), vecMul(b, a));
        }
        // Associator: [a,b,c] = (ab)c - a(bc)
        function vecAssoc(a, b, c) {
            return vecSub(vecMul(vecMul(a, b), c), vecMul(a, vecMul(b, c)));
        }

        // Funzione per creare base al volo (e_n)
        function createBaseVec(valVec) {
            // Il parser passa tutto come vettori. Prendiamo la parte scalare (indice 0)
            const n = valVec[0]; 
            const limit = parseInt(document.getElementById('calc-alg-select').value);
            
            if(!Number.isInteger(n)) throw "L'indice di base deve essere intero";
            if(n < 0 || n > limit) throw "Indice e_" + n + " non valido per l'algebra corrente (max " + limit + ")";
            
            const res = createZeroVector();
            res[n] = 1;
            return res;
        }

        const ops = {
            '+': { prec: 2, assoc: 'L', fn: vecAdd },
            '-': { prec: 2, assoc: 'L', fn: vecSub },
            '*': { prec: 3, assoc: 'L', fn: vecMul },
            '/': { prec: 3, assoc: 'L', fn: (a,b) => vecMul(a, vecInv(b)) }, 
            '~': { prec: 4, assoc: 'R', fn: (a) => vecScale(a, -1) }, // UNARY MINUS
            ',': { prec: 1, assoc: 'L', fn: null }, // Separator
            'norm': { type: 'func', fn: vecNorm },
            'conj': { type: 'func', fn: vecConj },
            'inv': { type: 'func', fn: vecInv },
            'e_':   { type: 'func', fn: createBaseVec }, // NUOVA FUNZIONE BASE
            'comm': { type: 'func_var', fn: null }, // Placeholder for parsing
            'comm2': { type: 'func', fn: vecComm }, // Real function 2 args
            'comm3': { type: 'func', fn: vecAssoc } // Real function 3 args
        };

function validateAssociativity(exprStr) {
            // 1. Normalizzazione Input
            exprStr = exprStr.replace(/\[/g, 'comm(').replace(/\]/g, ')');
            exprStr = exprStr.replace(/\s+/g, '');
            exprStr = exprStr.replace(/e_\((\d+)\)/g, 'e_$1');

            const alg = parseInt(document.getElementById('calc-alg-select').value);
            if(alg < 7) return; 

            // Tokenizer: separa operatori e parentesi
            let tokens = exprStr.split(/([+\-*/(),]|\bcomm\b|\bnorm\b|\bconj\b|\binv\b)/).filter(t => t);
            
            const isScalar = (token) => {
                if(!token) return true;
                if(!isNaN(parseFloat(token)) && !token.startsWith('e_')) return true;
                if(storedVars[token]) return storedVars[token].slice(1).every(val => Math.abs(val) < 1e-9);
                if(token.startsWith('Ans')) {
                    const idx = parseInt(token.substring(3)) - 1;
                    const ansVec = storedAns[idx];
                    if(ansVec) return ansVec.slice(1).every(val => Math.abs(val) < 1e-9);
                }
                if(token.startsWith('norm')) return true;
                if(token.startsWith('e_')) return parseInt(token.split('_')[1]) === 0;
                return false; 
            };

            let level = 0;
            let chain = []; 
            let lastWasOperand = false; // Fondamentale per distinguere il meno unario

            for(let i=0; i<tokens.length; i++) {
                let t = tokens[i];

                // --- GESTIONE PARENTESI E GRUPPI ---
                if(t === '(') {
                    level++;
                    lastWasOperand = false;
                    // Entrando in un gruppo, la logica interna √® isolata.
                    // Non resettiamo 'chain' qui, perch√© il gruppo stesso diventer√† un operando per 'chain'.
                    // Ma dobbiamo assicurarci di non contare ci√≤ che c'√® dentro per la catena esterna.
                    // Soluzione: usiamo uno stack o, pi√π semplicemente per questa validazione:
                    // Ignoriamo tutto finch√© non torniamo al livello 0.
                }
                else if(t === ')') {
                    level--;
                    if(level === 0) {
                        // Siamo usciti da una parentesi/funzione.
                        // Consideriamo tutto il blocco (...) come un UNICO operando generico.
                        // Usiamo un oggetto vuoto {} che √® unico ({} !== {}), cos√¨ (a)*b*(c) non sembrer√† a*b*a.
                        chain.push({}); 
                        lastWasOperand = true;
                    }
                }
                // --- GESTIONE LIVELLO 0 (Catena Principale) ---
                else if(level === 0) {
                    // Ignoriamo i nomi delle funzioni (inv, conj), aspettiamo la parentesi aperta
                    if(['norm','conj','inv','comm'].includes(t)) {
                        lastWasOperand = false;
                        continue;
                    }

                    // Operatori che resettano la catena (Somma, Virgola)
                    // Ma SOLO se sono binari! (cio√® se c'era un operando prima)
                    if(t === '+' || t === '-' || t === ',') {
                        if (lastWasOperand) {
                            // Operatore Binario (Sottrazione/Addizione) -> Spezza la catena
                            chain = [];
                            lastWasOperand = false;
                        } else {
                            // Operatore Unario (es. -a, +e_1) -> NON spezza la catena, lo ignoriamo
                        }
                    } 
                    // Operatori che continuano la catena (Moltiplicazione, Divisione)
                    else if(t === '*' || t === '/') {
                        lastWasOperand = false;
                        continue;
                    }
                    // Operandi (Variabili, Numeri, e_n)
                    else {
                        if(!isScalar(t)) {
                            chain.push(t);
                        }
                        lastWasOperand = true;

                        // --- 0. ECCEZIONE POTENZE (Monoassociativit√†) ---
                        // Valido solo se sono stringhe identiche (e_1 * e_1).
                        // I gruppi {} non sono mai uguali, quindi (a)*(a) viene bloccato (giustamente, per sicurezza).
                        const isPower = chain.every(val => (typeof val === 'string') && val === chain[0]);
                        if (isPower && chain.length > 0) continue;

                        // --- 1. CONTROLLO LUNGHEZZA ---
                        if(chain.length > 3) {
                             throw `Notazione ambigua: catena di ${chain.length} vettori senza parentesi.\nUsa le parentesi: es. (a*b)*(c*d)`;
                        }

                        // --- 2. CONTROLLO TERNE ---
                        if(chain.length === 3) {
                            const [A, B, C] = chain;
                            let isValid = false;

                            // Nota: A, B, C possono essere stringhe ('a') o oggetti ({} derivanti da gruppi)
                            // L'uguaglianza A===C funziona solo se sono stringhe identiche.
                            
                            if (alg === 7) { // Ottetti
                                if (A === B || B === C || A === C) isValid = true;
                            }
                            else if (alg === 15) { // Sedenioni
                                if (A === C) isValid = true;
                            }

                            if (!isValid) {
                                // Se ci sono gruppi coinvolti, il messaggio √® generico
                                const pA = (typeof A==='object') ? '(..)' : A;
                                const pB = (typeof B==='object') ? '(..)' : B;
                                const pC = (typeof C==='object') ? '(..)' : C;
                                throw `Notazione ambigua (3 termini).\nCalcolo: ${pA} * ${pB} * ${pC}\nSe usi gruppi (..), usa parentesi esterne o esplicita l'ordine.`;
                            }
                        }
                    }
                }
            }
        }

        function evaluateExpression(exprStr) {
            // --- 1. SMART COMMA & BRACKET PRE-PROCESSING ---
            // Gestisce correttamente annidamenti tipo [[a,b],c]
            let processedStr = "";
            let bracketDepth = 0;

            for(let i=0; i<exprStr.length; i++) {
                const char = exprStr[i];
                if(char === '[') {
                    bracketDepth++;
                    processedStr += char;
                } else if(char === ']') {
                    if(bracketDepth > 0) bracketDepth--;
                    processedStr += char;
                } else if(char === ',') {
                    // Se siamo dentro parentesi quadre (depth > 0), √® un separatore di argomenti.
                    // Altrimenti (depth 0), √® un punto decimale (es. 1,2 -> 1.2).
                    if(bracketDepth > 0) processedStr += ',';
                    else processedStr += '.';
                } else {
                    processedStr += char;
                }
            }
            
            // --- 2. TRANSLATE [ ] TO comm( ) ---
            // Convertiamo la sintassi [a,b] in comm(a,b) per il motore di calcolo esistente.
            // Il motore gestir√† automaticamente la differenza tra comm2 e comm3.
            exprStr = processedStr.replace(/\[/g, 'comm(').replace(/\]/g, ')');

            // Tokenizer modificato per includere "e_"
            let tokens = exprStr.replace(/\s+/g, '').split(/([+\-*/(),]|norm|conj|inv|comm|e_)/).filter(t => t);
            
            // Unary Minus Detection: if '-' is at start or follows operator/paren, change to '~'
            for(let i=0; i<tokens.length; i++) {
                if(tokens[i] === '-') {
                    const prev = i > 0 ? tokens[i-1] : null;
                    const isUnary = (i === 0) || (['+','-','*','/','(','comm',','].includes(prev));
                    if(isUnary) tokens[i] = '~';
                }
            }

            const outputQueue = [];
            const opStack = [];
            
            // Extended Shunting-Yard
            for(let i=0; i<tokens.length; i++) {
                const token = tokens[i];
                if (storedVars[token] || token.startsWith('Ans') || !isNaN(parseFloat(token))) { 
                    outputQueue.push(token); 
                } else if (ops[token] && (ops[token].type === 'func' || ops[token].type === 'func_var')) {
                    opStack.push(token);
                } else if (token === ',') {
                     // Separator: pop until '('
                    while (opStack.length > 0 && opStack[opStack.length-1] !== '(') {
                        outputQueue.push(opStack.pop());
                    }
                } else if (ops[token]) { 
                    while (opStack.length > 0) {
                        const top = opStack[opStack.length-1];
                        if (top === '(') break;
                        if ((ops[token].assoc === 'L' && ops[token].prec <= ops[top].prec) ||
                            (ops[token].assoc === 'R' && ops[token].prec < ops[top].prec)) {
                            outputQueue.push(opStack.pop());
                        } else { break; }
                    }
                    opStack.push(token);
                } else if (token === '(') {
                    opStack.push(token);
                } else if (token === ')') {
                    let commaCount = 0;
                    // Pop loop to find matching paren
                    while (opStack.length > 0 && opStack[opStack.length-1] !== '(') {
                        outputQueue.push(opStack.pop());
                    }
                    opStack.pop(); // Remove '('

                    // Check if function preceding '('
                    if (opStack.length > 0 && ops[opStack[opStack.length-1]].type === 'func_var') {
                        // We found a variable function (comm).
                        // We need to know how many args. 
                        // Simplified: Count commas inside the parenthesis scope.
                        // Since standard Shunting Yard doesn't track args easily, 
                        // we scan original tokens inside the parens we just closed?
                        // Hack: Count how many arguments were pushed to output queue? No.
                        
                        // Robust method: Count commas in the source string corresponding to this function call? 
                        // Or imply arg count from the output stack logic?
                        // Let's use a simpler heuristic for this calculator:
                        // Count commas in the token stream between the matching parens.
                        
                        // Let's re-scan tokens backward? No.
                        // Let's modify the comma handling. 
                        // When ',' is hit, we verify the function at top-1 of stack (under '(').
                        // Let's attach argCount to the stack object.
                    }
                    
                    // Actually, simpler approach for `comm`:
                    // Just look at the stack. If it's `comm`, we replace it with `comm2` or `comm3`.
                    // But RPN queue is linear.
                    // Let's do this: When evaluating RPN, if we see `comm`, we don't know if it's 2 or 3.
                    // Solution: Convert `comm` to `comm2` or `comm3` DURING tokenization or parsing.
                    
                    // Let's count commas in the current scope.
                    // Finding the scope in `tokens`: find matching `)` for the `(` after `comm`.
                }
            }
            while (opStack.length > 0) outputQueue.push(opStack.pop());

            // FIX: The above logic for `comm` is incomplete. 
            // Better strategy: Use a recursive evaluator or count args explicitly.
            // Since we can't easily rewrite the whole parser, let's fix `comm` handling by pre-processing.
            // Replace `comm(a,b,c)` with `comm3(a,b,c)` and `comm(a,b)` with `comm2(a,b)`.
            // Regex is hard with nested parens.
            
            // Let's do a quick pass to rename `comm`.
            let level = 0;
            let commScopes = []; // { start: index of 'comm', args: 1 }
            
            // Reset tokens for clarity
            const rawTokens = exprStr.replace(/\s+/g, '').split(/([+\-*/(),]|norm|conj|inv|comm)/).filter(t => t);
            tokens = []; // Ricostruiamo l'array pulito
            
            // Gestione Unary Plus (+) e Unary Minus (-)
            for(let i=0; i<rawTokens.length; i++) {
                const token = rawTokens[i];
                if(token === '+' || token === '-') {
                    const prev = i > 0 ? rawTokens[i-1] : null;
                    const isUnary = (i === 0) || (['+','-','*','/','(','comm',','].includes(prev));
                    
                    if(isUnary) {
                        if(token === '-') tokens.push('~'); // Il meno unario diventa tilde
                        // Il pi√π unario (+) lo ignoriamo (non lo aggiungiamo), perch√© +3 √® uguale a 3
                    } else {
                        tokens.push(token); // Operatore binario, lo teniamo
                    }
                } else {
                    tokens.push(token);
                }
            }

            // Identify comm arity
            for(let i=0; i<tokens.length; i++) {
                if(tokens[i] === 'comm') {
                    // Look ahead for (
                    // We need to find corresponding closing paren and count commas at this level.
                    let localLevel = 0;
                    let commCount = 0;
                    for(let j=i+1; j<tokens.length; j++) {
                        if(tokens[j] === '(') localLevel++;
                        else if(tokens[j] === ')') {
                            localLevel--;
                            if(localLevel === 0) break; // End of comm args
                        }
                        else if(tokens[j] === ',' && localLevel === 1) {
                            commCount++;
                        }
                    }
                    if(commCount === 1) tokens[i] = 'comm2';
                    else if(commCount === 2) tokens[i] = 'comm3';
                    else throw "Commutatore accetta solo 2 o 3 argomenti";
                }
            }

            // Re-run shunting yard with renamed tokens
             const finalQueue = [];
             const finalStack = [];
             
             for(let token of tokens) {
                 if (storedVars[token] || token.startsWith('Ans') || !isNaN(parseFloat(token))) { 
                     finalQueue.push(token); 
                 } else if (ops[token] && ops[token].type === 'func') {
                     finalStack.push(token);
                 } else if (token === ',') {
                     while (finalStack.length > 0 && finalStack[finalStack.length-1] !== '(') {
                         finalQueue.push(finalStack.pop());
                     }
                 } else if (ops[token]) { 
                     while (finalStack.length > 0) {
                         const top = finalStack[finalStack.length-1];
                         if (top === '(') break;
                         if ((ops[token].assoc === 'L' && ops[token].prec <= ops[top].prec) ||
                             (ops[token].assoc === 'R' && ops[token].prec < ops[top].prec)) {
                             finalQueue.push(finalStack.pop());
                         } else { break; }
                     }
                     finalStack.push(token);
                 } else if (token === '(') {
                     finalStack.push(token);
                 } else if (token === ')') {
                     while (finalStack.length > 0 && finalStack[finalStack.length-1] !== '(') {
                         finalQueue.push(finalStack.pop());
                     }
                     finalStack.pop(); 
                     if (finalStack.length > 0 && ops[finalStack[finalStack.length-1]].type === 'func') {
                         finalQueue.push(finalStack.pop());
                     }
                 }
             }
             while (finalStack.length > 0) finalQueue.push(finalStack.pop());

            // --- EVALUATION ---
            const evalStack = [];
            const getV = (t) => {
                if(typeof t !== 'string') return t; 
                if(storedVars[t]) {
                    const limit = parseInt(calcAlgSelect.value);
                    return storedVars[t].map((v,i) => i <= limit ? v : 0);
                } 
                if(t.startsWith('Ans')) {
                    const idx = parseInt(t.substring(3)) - 1;
                    return storedAns[idx] || createZeroVector();
                }
                const num = parseFloat(t);
                if(!isNaN(num)) { const v = createZeroVector(); v[0]=num; return v; }
                throw "Simbolo sconosciuto: " + t;
            };

            for(let token of finalQueue) {
                if(ops[token]) {
                    if(token === '~') {
                        const a = getV(evalStack.pop());
                        evalStack.push(ops[token].fn(a));
                    }
                    else if(token === 'comm3') {
                        const c = getV(evalStack.pop());
                        const b = getV(evalStack.pop());
                        const a = getV(evalStack.pop());
                        evalStack.push(ops[token].fn(a,b,c));
                    }
                    else if(ops[token].type === 'func') {
                        if(token === 'comm2') {
                             const b = getV(evalStack.pop());
                             const a = getV(evalStack.pop());
                             evalStack.push(ops[token].fn(a,b));
                        } else {
                            const a = getV(evalStack.pop());
                            evalStack.push(ops[token].fn(a));
                        }
                    } else {
                        // Binary ops
                        const b = getV(evalStack.pop());
                        const a = getV(evalStack.pop());
                        if(!a || !b) throw "Errore Sintassi";
                        evalStack.push(ops[token].fn(a, b));
                    }
                } else {
                    evalStack.push(token);
                }
            }
            return getV(evalStack[0]);
        }

	function setupGrid() {
            inputGrid.innerHTML = '';
            for(let i=0; i<=15; i++) {
                const l = i===0 ? '1' : 'e'+i;
                const customStyle = i === 0 ? 'border-color: #ffcc00;' : '';
                
                inputGrid.innerHTML += `
                    <div class="input-group" id="inp-grp-${i}" style="${customStyle}">
                        <span style="font-size:10px; color:#666; width:25px; text-align:center;">${l}</span>
                        <input class="num-input" data-idx="${i}" value="0">
                    </div>`;
            }

            // OPTIMIZATION: Event Delegation (Un solo listener invece di 16)
            // Controlla se abbiamo gi√† attaccato l'evento per evitare duplicati
            if (!inputGrid.hasAttribute('data-listener-attached')) {
                inputGrid.addEventListener('keydown', (e) => {
                    // Agisce solo se il target √® un input numerico
                    if (!e.target.classList.contains('num-input')) return;

                    const idx = parseInt(e.target.dataset.idx);
                    let dest = null;
                    
                    if(e.key === 'ArrowRight') dest = idx + 1;
                    else if(e.key === 'ArrowLeft') dest = idx - 1;
                    else if(e.key === 'ArrowDown') dest = idx + 4;
                    else if(e.key === 'ArrowUp') dest = idx - 4;
                    else return;

                    if(dest !== null && dest >= 0 && dest <= 15) {
                        const targetEl = document.querySelector(`.num-input[data-idx="${dest}"]`);
                        if(targetEl && !targetEl.parentElement.classList.contains('hidden')) {
                            e.preventDefault();
                            targetEl.focus();
                            targetEl.select();
                        }
                    }
                });
                inputGrid.setAttribute('data-listener-attached', 'true');
            }

            updateGridVisibility();
        }

        function updateGridVisibility() {
            const limit = parseInt(calcAlgSelect.value);
            for(let i=0; i<=15; i++) {
                const el = document.getElementById(`inp-grp-${i}`);
                if(i <= limit) el.classList.remove('hidden');
                else el.classList.add('hidden');
            }
        }

        function saveVar(varName) {
            const inputs = document.querySelectorAll('#input-grid input');
            inputs.forEach(inp => { storedVars[varName][parseInt(inp.dataset.idx)] = parseFloat(inp.value.replace(',', '.')) || 0; });
        }
        function setGrid(vector) {
            const inputs = document.querySelectorAll('#input-grid input');
            inputs.forEach(inp => { inp.value = vector[parseInt(inp.dataset.idx)]; });
        }
        function switchVar(newVar) {
            saveVar(currentVar);
            document.querySelectorAll('.var-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.var-tab[data-var="${newVar}"]`).classList.add('active');
            currentVar = newVar; setGrid(storedVars[newVar]);
        }
        document.querySelectorAll('.var-tab').forEach(tab => tab.addEventListener('click', () => switchVar(tab.dataset.var)));
        document.getElementById('btn-grid-clear').addEventListener('click', () => { setGrid(createZeroVector()); saveVar(currentVar); });
        document.getElementById('btn-grid-rand').addEventListener('click', () => {
            const limit = parseInt(calcAlgSelect.value);
            const v = createZeroVector();
            for(let i=0; i<=limit; i++) v[i] = Math.floor(Math.random()*21) - 10;
            setGrid(v); saveVar(currentVar);
        });
        calcAlgSelect.addEventListener('change', updateGridVisibility);

window.calcSmartParen = function() {
            const input = document.getElementById('expression-display');
            // Mette il focus se non c'√®, per garantire che cursor funzioni
            if (document.activeElement !== input) input.focus();

            const cursor = input.selectionStart;
            const text = input.value;
            const left = text.substring(0, cursor);
            
            // Conta quante aperte e chiuse ci sono PRIMA del cursore
            const openCount = (left.match(/\(/g) || []).length;
            const closeCount = (left.match(/\)/g) || []).length;
            
            // Prende l'ultimo carattere non-spazio prima del cursore
            const lastCharMatch = left.trim().match(/.$/);
            const lastChar = lastCharMatch ? lastCharMatch[0] : '';
            
            // LOGICA: Chiudi SE ci sono parentesi aperte in sospeso E l'ultimo carattere 
            // √® un numero, una lettera, una chiusura o un punto. Altrimenti Apri.
            const isOperandEnd = /[0-9a-zA-Z_\)\]\.]$/.test(lastChar);
            
            if (openCount > closeCount && isOperandEnd) {
                calcInput(')');
            } else {
                calcInput('(');
            }
        };

window.calcBracket = function() {
            const input = document.getElementById('expression-display');
            if (document.activeElement !== input) input.focus();
            
            const cursor = input.selectionStart;
            const text = input.value;
            const left = text.substring(0, cursor).trim(); // Ignora spazi finali
            
            // Logica: Chiudi se l'ultimo carattere √® un valore, una chiusura o un punto.
            // Altrimenti apri (inizio riga, operatore, virgola, aperta parentesi).
            const shouldClose = /[0-9a-zA-Z_\)\]\.]$/.test(left);
            
            calcInput(shouldClose ? ']' : '[');
        };

        window.calcInput = function(val) { 
            const input = document.getElementById('expression-display');
            
            // Se l'input non ha il focus, aggiungi alla fine (comportamento fallback)
            // Ma se l'utente ha cliccato, useremo la posizione del cursore
            if (document.activeElement !== input) {
                input.focus();
            }

            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;

            // Inserisci il testo nella posizione del cursore o sostituisci la selezione
            input.value = text.substring(0, start) + val + text.substring(end);

            // Sposta il cursore subito dopo il testo inserito
            const newPos = start + val.length;
            input.setSelectionRange(newPos, newPos);
        };
        const historyOverlay = document.getElementById('history-overlay');
        const toggleHistoryBtn = document.getElementById('toggle-history-btn');
        toggleHistoryBtn.addEventListener('click', () => { historyOverlay.classList.toggle('open'); toggleHistoryBtn.classList.toggle('active'); });

// Gestione tasto Invio per la calcolatrice
document.getElementById('expression-display').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        calcAction('eval');
    }
});

        window.calcAction = function(action) {
            const disp = document.getElementById('expression-display');
            const resDisp = document.getElementById('result-display'); 
            
            // --- AZIONE: CANCELLA TUTTO (AC) ---
            if(action === 'clear') { 
                disp.value = ''; 
                resDisp.innerText = '0'; 
                disp.focus(); 
            }
            
            // --- AZIONE: BACKSPACE (Intelligente) ---
            if(action === 'back') {
                const start = disp.selectionStart;
                const end = disp.selectionEnd;
                const text = disp.value;

                if (start !== end) {
                    // Se c'√® del testo selezionato, lo cancella
                    disp.value = text.substring(0, start) + text.substring(end);
                    disp.setSelectionRange(start, start);
                } else if (start > 0) {
                    // Altrimenti cancella il carattere PRIMA del cursore
                    disp.value = text.substring(0, start - 1) + text.substring(end);
                    disp.setSelectionRange(start - 1, start - 1);
                }
                disp.focus();
            }

            // --- AZIONE: CALCOLA (=) ---
            if(action === 'eval') {
                saveVar(currentVar); 
                try {
                    // 1. Controllo Assciativit√† (Ottetti/Sedenioni)
                    // Se la funzione esiste (l'abbiamo aggiunta prima), la esegue
                    if(typeof validateAssociativity === 'function') {
                        validateAssociativity(disp.value);
                    }

                    // 2. Valutazione Espressione
                    const res = evaluateExpression(disp.value);
                    const ansId = storedAns.length + 1;
                    storedAns.push(res);
                    
                    // 3. Formattazione Risultato
                    const formatVec = (v) => {
                        let s = []; let allZero = true;
                        v.forEach((val, i) => {
                            if(Math.abs(val) > 0.001) {
                                allZero = false;
                                let term = (val < 0 ? "-" : "+") + Math.abs(parseFloat(val.toFixed(3)));
                                if(i > 0) term += "e<sub>" + i + "</sub>"; 
                                s.push(term);
                            }
                        });
                        if(allZero) return "0";
                        let str = s.join(' ');
                        if(str.startsWith('+')) str = str.substring(1);
                        return str;
                    };

                    const resString = formatVec(res);
                    resDisp.innerHTML = "= " + resString;

                    // 4. Aggiornamento Log/Cronologia
                    const log = document.getElementById('calc-log');
                    if(log.children.length === 1 && log.children[0].innerText.includes('Nessun')) log.innerHTML = '';
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.innerHTML = `<div class="log-expr">Ans${ansId}: ${disp.value}</div><div class="log-res">= ${resString}</div>`;
                    entry.addEventListener('click', () => { 
                        // Inserisce AnsX dove si trova il cursore
                        const input = document.getElementById('expression-display');
                        const val = `Ans${ansId}`;
                        const start = input.selectionStart;
                        const end = input.selectionEnd;
                        input.value = input.value.substring(0, start) + val + input.value.substring(end);
                        historyOverlay.classList.remove('open'); 
                        toggleHistoryBtn.classList.remove('active'); 
                        input.focus();
                    });
                    log.prepend(entry);

                } catch(e) { 
                    resDisp.innerText = "Err"; 
                    console.error(e); 
                    alert("Errore: " + e); 
                }
            }
        };

        document.getElementById('btn-clear-log').addEventListener('click', () => {
            document.getElementById('calc-log').innerHTML = '<div style="text-align:center; color:#555; margin-top:20px; font-size:12px;">Nessun calcolo recente</div>';
            storedAns = [];
        });

        // --- LOGICA APERTURA / CHIUSURA (TOGGLE) ---
        
        // Funzione mancante aggiunta per permettere l'interazione con formule e divisori
        function openCalculator() {
            const isOpen = calcModal.classList.contains('active');
            if (!isOpen) {
                calcModal.classList.add('active');
                calcToggle.classList.add('active');
                
                // FIX: Chiude sempre la cronologia all'apertura
                historyOverlay.classList.remove('open');
                toggleHistoryBtn.classList.remove('active');

                calcAlgSelect.value = currentAlgState; 
                updateGridVisibility();
                
                // Reset posizione al centro se non √® mai stata mossa
                if (!calcModal.style.left) {
                    calcModal.style.top = '50%';
                    calcModal.style.left = '50%';
                    calcModal.style.transform = 'translate(-50%, -50%)';
                }
            }
        }

        function toggleCalculator() {
            const isOpen = calcModal.classList.contains('active');
            if (isOpen) {
                // Chiudi
                calcModal.classList.remove('active');
                calcToggle.classList.remove('active');
            } else {
                // Apri
                calcModal.classList.add('active');
                calcToggle.classList.add('active'); // Colore blu
                
                // FIX: Chiude sempre la cronologia all'apertura
                historyOverlay.classList.remove('open');
                toggleHistoryBtn.classList.remove('active');

                calcAlgSelect.value = currentAlgState;
                updateGridVisibility();
                
                // Reset posizione al centro se non √® mai stata mossa (opzionale)
                if (!calcModal.style.left) {
                    calcModal.style.top = '50%';
                    calcModal.style.left = '50%';
                    calcModal.style.transform = 'translate(-50%, -50%)';
                }
            }
        }

        calcToggle.addEventListener('click', toggleCalculator);
        calcClose.addEventListener('click', () => {
            calcModal.classList.remove('active');
            calcToggle.classList.remove('active');
        });
        setupGrid();

        // --- LOGICA TRASCINAMENTO (DRAG & DROP) ---
        const calcHeader = document.querySelector('.calc-header');
        calcHeader.style.cursor = 'move'; // Cambia cursore
        
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        calcHeader.addEventListener('mousedown', (e) => {
            // Impedisce il drag se clicchi sui pulsanti dentro l'header
            if(e.target.closest('.icon-btn') || e.target.closest('select')) return;
            
            e.preventDefault();
            isDragging = true;
            
            // Calcola la posizione attuale per evitare scatti
            const rect = calcModal.getBoundingClientRect();
            
            // Disabilita il centraggio CSS automatico
            calcModal.style.transform = 'none'; 
            calcModal.style.margin = '0';
            calcModal.style.left = rect.left + 'px';
            calcModal.style.top = rect.top + 'px';
            
            // Calcola dove hai cliccato rispetto all'angolo della finestra
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            // Muovi la finestra
            calcModal.style.left = (e.clientX - dragOffsetX) + 'px';
            calcModal.style.top = (e.clientY - dragOffsetY) + 'px';
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('resize', () => {
            const w = container.clientWidth; const h = container.clientHeight;
            camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); labelRenderer.setSize(w, h);
        });

        // --- NUOVO: Logica Click & Hold sulle sfere ---
        const raycaster = new THREE.Raycaster();
        const mouseVec = new THREE.Vector2();
        let isHoldingPoint = false;

        function highlightConnections(pointId) {
            // 1. Nascondi tutto
            tripletVisuals.forEach(t => { 
                t.mesh.visible = false; 
                if(t.hitMesh) t.hitMesh.visible = false; 
            });
            for(let k in pointObjects) {
                pointObjects[k].mesh.visible = false;
                pointObjects[k].label.visible = false;
            }

            // 2. Mostra punto
            if(pointObjects[pointId]) {
                pointObjects[pointId].mesh.visible = true;
                pointObjects[pointId].label.visible = true;
            }

            // 3. Mostra terne collegate
            POSITIVE_TRIPLETS.forEach((triplet, idx) => {
                if(triplet.includes(pointId) && triplet.every(val => val <= currentAlgState)) {
                    tripletVisuals[idx].mesh.visible = true;
                    if(tripletVisuals[idx].hitMesh) tripletVisuals[idx].hitMesh.visible = true;
                    
                    triplet.forEach(pId => {
                        pointObjects[pId].mesh.visible = true;
                        pointObjects[pId].label.visible = true;
                    });
                }
            });
        }

        function highlightSingleTriplet(tripletIdx) {
            tripletVisuals.forEach(t => { 
                t.mesh.visible = false; 
                if(t.hitMesh) t.hitMesh.visible = false; 
            });
            for(let k in pointObjects) {
                pointObjects[k].mesh.visible = false;
                pointObjects[k].label.visible = false;
            }

            const tObj = tripletVisuals[tripletIdx];
            if(tObj) {
                tObj.mesh.visible = true;
                if(tObj.hitMesh) tObj.hitMesh.visible = true;
                tObj.ids.forEach(pId => {
                    if(pointObjects[pId]) {
                        pointObjects[pId].mesh.visible = true;
                        pointObjects[pId].label.visible = true;
                    }
                });
            }
        }

        renderer.domElement.addEventListener('pointerdown', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouseVec.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouseVec.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouseVec, camera);
            
            const visibleMeshes = [];
            const meshData = new Map(); 

            // Punti
            for(let idStr in pointObjects) {
                const id = parseInt(idStr);
                if(pointObjects[id].mesh.visible) {
                    visibleMeshes.push(pointObjects[id].mesh);
                    meshData.set(pointObjects[id].mesh, { type: 'point', id: id });
                }
            }

            // Ora solo i punti vengono aggiunti a visibleMeshes
            
            const intersects = raycaster.intersectObjects(visibleMeshes);
            if(intersects.length > 0) {
                const data = meshData.get(intersects[0].object);
                
                // Mantiene attiva solo l'evidenziazione dei punti
                if(data.type === 'point') {
                    highlightConnections(data.id);
                    isHoldingPoint = true;
                }
            }
        });



        // Evento: Rilascio
        window.addEventListener('pointerup', () => {
            if(isHoldingPoint) {
                isHoldingPoint = false;
                // Non serve riabilitare i controlli perch√© non li abbiamo disabilitati
                filterSubspace(currentAlgState); // Ripristina la vista normale
            }
        });
        // ----------------------------------------------

	// --- LOGICA RESIZER ORIZZONTALE PERFETTA ---
        const tableResizer = document.getElementById('table-resizer');
        const tableScroll = document.getElementById('table-scroll');
        const sidebarContent = document.getElementById('sidebar');
        let isResizingTable = false;
        let startY = 0;
        let startHeight = 0;
        let animationFrameId = null;

        tableResizer.addEventListener('pointerdown', (e) => {
            isResizingTable = true;
            // Salviamo la posizione iniziale del tocco e l'altezza attuale
            startY = e.clientY;
            startHeight = tableScroll.offsetHeight;
            
            tableResizer.classList.add('active');
            document.body.style.cursor = 'ns-resize';
            tableResizer.setPointerCapture(e.pointerId);
            e.preventDefault();
        });

        window.addEventListener('pointermove', (e) => {
            if (!isResizingTable) return;

            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            animationFrameId = requestAnimationFrame(() => {
                // Calcoliamo la differenza di movimento (delta)
                const deltaY = e.clientY - startY;
                let newHeight = startHeight + deltaY;
                
                // Limiti: min 80px, max altezza sidebar meno spazio per formule
                const sidebarHeight = sidebarContent.offsetHeight;
                newHeight = Math.max(80, Math.min(sidebarHeight - 150, newHeight));
                
                tableScroll.style.height = newHeight + 'px';
                // Rimuoviamo il flex per dare priorit√† all'altezza fissa in pixel
                tableScroll.style.flex = "none"; 
            });
        });

        window.addEventListener('pointerup', (e) => {
            if (!isResizingTable) return;
            isResizingTable = false;
            document.body.style.cursor = 'default';
            tableResizer.releasePointerCapture(e.pointerId);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        });

        window.addEventListener('pointerup', () => {
            if (!isResizingTable) return;
            isResizingTable = false;
            document.body.style.cursor = 'default';
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        });

        // --- OTTIMIZZAZIONE LOOP DI RENDERING ---
        let renderRequested = true; // Flag per forzare il render
        
        // Renderizza solo quando la camera si muove
        controls.addEventListener('change', () => { renderRequested = true; });
        
        // Renderizza quando si ridimensiona la finestra
        window.addEventListener('resize', () => { renderRequested = true; });
        
        // Renderizza quando si interagisce con la UI (click generico)
        window.addEventListener('pointerup', () => { renderRequested = true; setTimeout(()=> renderRequested=true, 100); });
        
        // Renderizza quando si preme un tasto (es. calcolatrice)
        window.addEventListener('keydown', () => { renderRequested = true; });

        // Forza render quando cambia la UI laterale o i menu
        const forceUpdate = () => { renderRequested = true; };
        document.querySelectorAll('.tab-btn, .triplet-btn, .ui-btn, .setting-action').forEach(b => {
            b.addEventListener('click', forceUpdate);
        });

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);

            // --- PROTEZIONE BUG ZOOM ---
            // Se la camera finisce nell'infinito o diventa NaN, resetta d'emergenza
            if (isNaN(camera.position.x) || !isFinite(camera.position.x)) {
                camera.position.copy(initialCameraPos);
                controls.target.set(0, 3, 0);
                controls.update();
            }
            
            const delta = Math.min(clock.getDelta(), 0.1);
            let needsRender = renderRequested;

            // Se l'animazione NON √® in pausa e la velocit√† > 0, dobbiamo renderizzare sempre
            if (!animParams.paused && animParams.speed > 0) {
                animParams.customTime += delta * animParams.speed;
                animatedMaterials.forEach(mat => mat.uniforms.customTime.value = animParams.customTime);
                needsRender = true;
            }

            // Animazione sfondo stellato (se attivo)
            if(starField.visible) { 
                starField.rotation.y += 0.0003; 
                if(!animParams.paused) needsRender = true; 
            }

            // Se necessario, aggiorna i controlli e renderizza
            if (needsRender) {
                controls.update();
                renderer.render(scene, camera);
                labelRenderer.render(scene, camera);
                renderRequested = false; // Reset flag
            }
        }
        animate();
        // Forza un render iniziale
        renderRequested = true;
        
        // Applica i colori corretti all'avvio (Ora √® sicuro chiamarlo qui)
        updateCycleColors();

// =============================================================
        // =================== SCORCIATOIE TASTIERA ====================
        // =============================================================

        window.addEventListener('keydown', (e) => {
            // Controlla se l'utente sta gi√† scrivendo in un campo di input (es. dentro la calcolatrice)
            const activeTag = document.activeElement.tagName.toLowerCase();
            const isInputActive = (activeTag === 'input' || activeTag === 'textarea');

            // --- AZIONI GLOBALI (Solo se NON si sta gi√† scrivendo) ---
            if (!isInputActive) {

                // 1. SPAZIO: Play/Pausa
                if (e.code === 'Space') {
                    e.preventDefault(); // Evita lo scroll della pagina
                    document.getElementById('play-pause-btn').click();
                    return;
                }

                // 2. INVIO: Reset Vista Camera
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('home-btn').click();
                    return;
                }

                // 3. FRECCE SU/GIU: Controllo Velocit√†
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault(); // Evita scroll
                    const slider = document.getElementById('speed-slider');
                    let val = parseFloat(slider.value);
                    const step = 0.1;

                    if (e.key === 'ArrowUp') {
                        val = Math.min(val + step, parseFloat(slider.max));
                    } else {
                        val = Math.max(val - step, parseFloat(slider.min));
                    }

                    slider.value = val.toFixed(1);
                    // Scatena l'evento 'input' per aggiornare la variabile animParams e la label UI
                    slider.dispatchEvent(new Event('input'));
                    return;
                }

                // 4. DIGITAZIONE RAPIDA CALCOLATRICE
                // Accetta: Lettere (a-z), Numeri (0-9), Parentesi () [], Operatori + -, Punto .
                const allowedKeys = /^[a-zA-Z0-9\(\)\[\]\+\-\.]$/;

                // Controlliamo che sia un tasto singolo (evita F1, Tab, ecc) e che sia nella lista
                if (e.key.length === 1 && allowedKeys.test(e.key)) {
                    e.preventDefault();
                    
                    // Apre la calcolatrice (funzione esistente nel tuo script)
                    openCalculator();

                    const display = document.getElementById('expression-display');
                    
                    // Aggiunge il carattere digitato al valore attuale
                    display.value += e.key;
                    
                    // Mette il focus sulla casella e sposta il cursore alla fine
                    display.focus();
                    display.setSelectionRange(display.value.length, display.value.length);
                }
            }
        });
    </script>
</body>
</html>